// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/nucleo.proto

#ifndef PROTOBUF_INCLUDED_goldo_2fnucleo_2eproto
#define PROTOBUF_INCLUDED_goldo_2fnucleo_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "goldo/nucleo/hal.pb.h"
#include "goldo/nucleo/odometry.pb.h"
#include "goldo/nucleo/propulsion.pb.h"
#include "goldo/nucleo/robot_simulator.pb.h"
#include "goldo/nucleo/servos.pb.h"
#include "goldo/nucleo/odrive.pb.h"
#include "goldo/nucleo/statistics.pb.h"
#include "goldo/pb2_options.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2fnucleo_2eproto 

namespace protobuf_goldo_2fnucleo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2fnucleo_2eproto
namespace goldo {
namespace nucleo {
class FreeRTOSTaskStats;
class FreeRTOSTaskStatsDefaultTypeInternal;
extern FreeRTOSTaskStatsDefaultTypeInternal _FreeRTOSTaskStats_default_instance_;
class FreeRTOSTasksStats;
class FreeRTOSTasksStatsDefaultTypeInternal;
extern FreeRTOSTasksStatsDefaultTypeInternal _FreeRTOSTasksStats_default_instance_;
class NucleoConfig;
class NucleoConfigDefaultTypeInternal;
extern NucleoConfigDefaultTypeInternal _NucleoConfig_default_instance_;
class NucleoState;
class NucleoStateDefaultTypeInternal;
extern NucleoStateDefaultTypeInternal _NucleoState_default_instance_;
class NucleoTasksState;
class NucleoTasksStateDefaultTypeInternal;
extern NucleoTasksStateDefaultTypeInternal _NucleoTasksState_default_instance_;
class NucleoTasksStatistics;
class NucleoTasksStatisticsDefaultTypeInternal;
extern NucleoTasksStatisticsDefaultTypeInternal _NucleoTasksStatistics_default_instance_;
class ScopeChannelConfig;
class ScopeChannelConfigDefaultTypeInternal;
extern ScopeChannelConfigDefaultTypeInternal _ScopeChannelConfig_default_instance_;
class ScopeChannelValues;
class ScopeChannelValuesDefaultTypeInternal;
extern ScopeChannelValuesDefaultTypeInternal _ScopeChannelValues_default_instance_;
class ScopeConfig;
class ScopeConfigDefaultTypeInternal;
extern ScopeConfigDefaultTypeInternal _ScopeConfig_default_instance_;
class ScopeData;
class ScopeDataDefaultTypeInternal;
extern ScopeDataDefaultTypeInternal _ScopeData_default_instance_;
class ScopeValues;
class ScopeValuesDefaultTypeInternal;
extern ScopeValuesDefaultTypeInternal _ScopeValues_default_instance_;
class SensorConfig;
class SensorConfigDefaultTypeInternal;
extern SensorConfigDefaultTypeInternal _SensorConfig_default_instance_;
}  // namespace nucleo
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::nucleo::FreeRTOSTaskStats* Arena::CreateMaybeMessage<::goldo::nucleo::FreeRTOSTaskStats>(Arena*);
template<> ::goldo::nucleo::FreeRTOSTasksStats* Arena::CreateMaybeMessage<::goldo::nucleo::FreeRTOSTasksStats>(Arena*);
template<> ::goldo::nucleo::NucleoConfig* Arena::CreateMaybeMessage<::goldo::nucleo::NucleoConfig>(Arena*);
template<> ::goldo::nucleo::NucleoState* Arena::CreateMaybeMessage<::goldo::nucleo::NucleoState>(Arena*);
template<> ::goldo::nucleo::NucleoTasksState* Arena::CreateMaybeMessage<::goldo::nucleo::NucleoTasksState>(Arena*);
template<> ::goldo::nucleo::NucleoTasksStatistics* Arena::CreateMaybeMessage<::goldo::nucleo::NucleoTasksStatistics>(Arena*);
template<> ::goldo::nucleo::ScopeChannelConfig* Arena::CreateMaybeMessage<::goldo::nucleo::ScopeChannelConfig>(Arena*);
template<> ::goldo::nucleo::ScopeChannelValues* Arena::CreateMaybeMessage<::goldo::nucleo::ScopeChannelValues>(Arena*);
template<> ::goldo::nucleo::ScopeConfig* Arena::CreateMaybeMessage<::goldo::nucleo::ScopeConfig>(Arena*);
template<> ::goldo::nucleo::ScopeData* Arena::CreateMaybeMessage<::goldo::nucleo::ScopeData>(Arena*);
template<> ::goldo::nucleo::ScopeValues* Arena::CreateMaybeMessage<::goldo::nucleo::ScopeValues>(Arena*);
template<> ::goldo::nucleo::SensorConfig* Arena::CreateMaybeMessage<::goldo::nucleo::SensorConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace nucleo {

enum ScopeChannelConfig_Encoding {
  ScopeChannelConfig_Encoding_RAW8 = 0,
  ScopeChannelConfig_Encoding_RAW16 = 1,
  ScopeChannelConfig_Encoding_RAW32 = 2,
  ScopeChannelConfig_Encoding_SCALED8 = 4,
  ScopeChannelConfig_Encoding_SCALED16 = 5,
  ScopeChannelConfig_Encoding_SCALED32 = 6,
  ScopeChannelConfig_Encoding_FLOAT32 = 8,
  ScopeChannelConfig_Encoding_ScopeChannelConfig_Encoding_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ScopeChannelConfig_Encoding_ScopeChannelConfig_Encoding_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ScopeChannelConfig_Encoding_IsValid(int value);
const ScopeChannelConfig_Encoding ScopeChannelConfig_Encoding_Encoding_MIN = ScopeChannelConfig_Encoding_RAW8;
const ScopeChannelConfig_Encoding ScopeChannelConfig_Encoding_Encoding_MAX = ScopeChannelConfig_Encoding_FLOAT32;
const int ScopeChannelConfig_Encoding_Encoding_ARRAYSIZE = ScopeChannelConfig_Encoding_Encoding_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScopeChannelConfig_Encoding_descriptor();
inline const ::std::string& ScopeChannelConfig_Encoding_Name(ScopeChannelConfig_Encoding value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScopeChannelConfig_Encoding_descriptor(), value);
}
inline bool ScopeChannelConfig_Encoding_Parse(
    const ::std::string& name, ScopeChannelConfig_Encoding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScopeChannelConfig_Encoding>(
    ScopeChannelConfig_Encoding_descriptor(), name, value);
}
enum SensorType {
  UNKNOWN = 0,
  NUCLEO = 1,
  FPGA = 2,
  SensorType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SensorType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SensorType_IsValid(int value);
const SensorType SensorType_MIN = UNKNOWN;
const SensorType SensorType_MAX = FPGA;
const int SensorType_ARRAYSIZE = SensorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SensorType_descriptor();
inline const ::std::string& SensorType_Name(SensorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SensorType_descriptor(), value);
}
inline bool SensorType_Parse(
    const ::std::string& name, SensorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SensorType>(
    SensorType_descriptor(), name, value);
}
// ===================================================================

class SensorConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.SensorConfig) */ {
 public:
  SensorConfig();
  virtual ~SensorConfig();

  SensorConfig(const SensorConfig& from);

  inline SensorConfig& operator=(const SensorConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorConfig(SensorConfig&& from) noexcept
    : SensorConfig() {
    *this = ::std::move(from);
  }

  inline SensorConfig& operator=(SensorConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorConfig* internal_default_instance() {
    return reinterpret_cast<const SensorConfig*>(
               &_SensorConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SensorConfig* other);
  friend void swap(SensorConfig& a, SensorConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorConfig* New() const final {
    return CreateMaybeMessage<SensorConfig>(NULL);
  }

  SensorConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorConfig& from);
  void MergeFrom(const SensorConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 64 [(.goldo.pb2_options.cpp_type) = VOID];
  void clear_name();
  static const int kNameFieldNumber = 64;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .goldo.nucleo.SensorType type = 1 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::goldo::nucleo::SensorType type() const;
  void set_type(::goldo::nucleo::SensorType value);

  // int32 id = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.SensorConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NucleoConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.NucleoConfig) */ {
 public:
  NucleoConfig();
  virtual ~NucleoConfig();

  NucleoConfig(const NucleoConfig& from);

  inline NucleoConfig& operator=(const NucleoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NucleoConfig(NucleoConfig&& from) noexcept
    : NucleoConfig() {
    *this = ::std::move(from);
  }

  inline NucleoConfig& operator=(NucleoConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NucleoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NucleoConfig* internal_default_instance() {
    return reinterpret_cast<const NucleoConfig*>(
               &_NucleoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NucleoConfig* other);
  friend void swap(NucleoConfig& a, NucleoConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NucleoConfig* New() const final {
    return CreateMaybeMessage<NucleoConfig>(NULL);
  }

  NucleoConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NucleoConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NucleoConfig& from);
  void MergeFrom(const NucleoConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NucleoConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.nucleo.servos.ServoConfig servos = 6;
  int servos_size() const;
  void clear_servos();
  static const int kServosFieldNumber = 6;
  ::goldo::nucleo::servos::ServoConfig* mutable_servos(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::ServoConfig >*
      mutable_servos();
  const ::goldo::nucleo::servos::ServoConfig& servos(int index) const;
  ::goldo::nucleo::servos::ServoConfig* add_servos();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::ServoConfig >&
      servos() const;

  // repeated .goldo.nucleo.SensorConfig sensors = 7;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 7;
  ::goldo::nucleo::SensorConfig* mutable_sensors(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::SensorConfig >*
      mutable_sensors();
  const ::goldo::nucleo::SensorConfig& sensors(int index) const;
  ::goldo::nucleo::SensorConfig* add_sensors();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::SensorConfig >&
      sensors() const;

  // repeated string enabled_tasks = 8;
  int enabled_tasks_size() const;
  void clear_enabled_tasks();
  static const int kEnabledTasksFieldNumber = 8;
  const ::std::string& enabled_tasks(int index) const;
  ::std::string* mutable_enabled_tasks(int index);
  void set_enabled_tasks(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_enabled_tasks(int index, ::std::string&& value);
  #endif
  void set_enabled_tasks(int index, const char* value);
  void set_enabled_tasks(int index, const char* value, size_t size);
  ::std::string* add_enabled_tasks();
  void add_enabled_tasks(const ::std::string& value);
  #if LANG_CXX11
  void add_enabled_tasks(::std::string&& value);
  #endif
  void add_enabled_tasks(const char* value);
  void add_enabled_tasks(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& enabled_tasks() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_enabled_tasks();

  // repeated .goldo.nucleo.servos.LiftConfig lifts = 9;
  int lifts_size() const;
  void clear_lifts();
  static const int kLiftsFieldNumber = 9;
  ::goldo::nucleo::servos::LiftConfig* mutable_lifts(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::LiftConfig >*
      mutable_lifts();
  const ::goldo::nucleo::servos::LiftConfig& lifts(int index) const;
  ::goldo::nucleo::servos::LiftConfig* add_lifts();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::LiftConfig >&
      lifts() const;

  // .goldo.nucleo.hal.HalConfig hal = 1;
  bool has_hal() const;
  void clear_hal();
  static const int kHalFieldNumber = 1;
  private:
  const ::goldo::nucleo::hal::HalConfig& _internal_hal() const;
  public:
  const ::goldo::nucleo::hal::HalConfig& hal() const;
  ::goldo::nucleo::hal::HalConfig* release_hal();
  ::goldo::nucleo::hal::HalConfig* mutable_hal();
  void set_allocated_hal(::goldo::nucleo::hal::HalConfig* hal);

  // .goldo.nucleo.robot_simulator.RobotSimulatorConfig robot_simulator = 2;
  bool has_robot_simulator() const;
  void clear_robot_simulator();
  static const int kRobotSimulatorFieldNumber = 2;
  private:
  const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig& _internal_robot_simulator() const;
  public:
  const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig& robot_simulator() const;
  ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* release_robot_simulator();
  ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* mutable_robot_simulator();
  void set_allocated_robot_simulator(::goldo::nucleo::robot_simulator::RobotSimulatorConfig* robot_simulator);

  // .goldo.nucleo.odometry.OdometryConfig odometry = 3;
  bool has_odometry() const;
  void clear_odometry();
  static const int kOdometryFieldNumber = 3;
  private:
  const ::goldo::nucleo::odometry::OdometryConfig& _internal_odometry() const;
  public:
  const ::goldo::nucleo::odometry::OdometryConfig& odometry() const;
  ::goldo::nucleo::odometry::OdometryConfig* release_odometry();
  ::goldo::nucleo::odometry::OdometryConfig* mutable_odometry();
  void set_allocated_odometry(::goldo::nucleo::odometry::OdometryConfig* odometry);

  // .goldo.nucleo.propulsion.PropulsionControllerConfig propulsion = 4;
  bool has_propulsion() const;
  void clear_propulsion();
  static const int kPropulsionFieldNumber = 4;
  private:
  const ::goldo::nucleo::propulsion::PropulsionControllerConfig& _internal_propulsion() const;
  public:
  const ::goldo::nucleo::propulsion::PropulsionControllerConfig& propulsion() const;
  ::goldo::nucleo::propulsion::PropulsionControllerConfig* release_propulsion();
  ::goldo::nucleo::propulsion::PropulsionControllerConfig* mutable_propulsion();
  void set_allocated_propulsion(::goldo::nucleo::propulsion::PropulsionControllerConfig* propulsion);

  // .goldo.nucleo.propulsion.PropulsionTaskConfig propulsion_task = 5;
  bool has_propulsion_task() const;
  void clear_propulsion_task();
  static const int kPropulsionTaskFieldNumber = 5;
  private:
  const ::goldo::nucleo::propulsion::PropulsionTaskConfig& _internal_propulsion_task() const;
  public:
  const ::goldo::nucleo::propulsion::PropulsionTaskConfig& propulsion_task() const;
  ::goldo::nucleo::propulsion::PropulsionTaskConfig* release_propulsion_task();
  ::goldo::nucleo::propulsion::PropulsionTaskConfig* mutable_propulsion_task();
  void set_allocated_propulsion_task(::goldo::nucleo::propulsion::PropulsionTaskConfig* propulsion_task);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.NucleoConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::ServoConfig > servos_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::SensorConfig > sensors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> enabled_tasks_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::LiftConfig > lifts_;
  ::goldo::nucleo::hal::HalConfig* hal_;
  ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* robot_simulator_;
  ::goldo::nucleo::odometry::OdometryConfig* odometry_;
  ::goldo::nucleo::propulsion::PropulsionControllerConfig* propulsion_;
  ::goldo::nucleo::propulsion::PropulsionTaskConfig* propulsion_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NucleoTasksState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.NucleoTasksState) */ {
 public:
  NucleoTasksState();
  virtual ~NucleoTasksState();

  NucleoTasksState(const NucleoTasksState& from);

  inline NucleoTasksState& operator=(const NucleoTasksState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NucleoTasksState(NucleoTasksState&& from) noexcept
    : NucleoTasksState() {
    *this = ::std::move(from);
  }

  inline NucleoTasksState& operator=(NucleoTasksState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NucleoTasksState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NucleoTasksState* internal_default_instance() {
    return reinterpret_cast<const NucleoTasksState*>(
               &_NucleoTasksState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NucleoTasksState* other);
  friend void swap(NucleoTasksState& a, NucleoTasksState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NucleoTasksState* New() const final {
    return CreateMaybeMessage<NucleoTasksState>(NULL);
  }

  NucleoTasksState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NucleoTasksState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NucleoTasksState& from);
  void MergeFrom(const NucleoTasksState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NucleoTasksState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool comm_uart = 1;
  void clear_comm_uart();
  static const int kCommUartFieldNumber = 1;
  bool comm_uart() const;
  void set_comm_uart(bool value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.NucleoTasksState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool comm_uart_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NucleoTasksStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.NucleoTasksStatistics) */ {
 public:
  NucleoTasksStatistics();
  virtual ~NucleoTasksStatistics();

  NucleoTasksStatistics(const NucleoTasksStatistics& from);

  inline NucleoTasksStatistics& operator=(const NucleoTasksStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NucleoTasksStatistics(NucleoTasksStatistics&& from) noexcept
    : NucleoTasksStatistics() {
    *this = ::std::move(from);
  }

  inline NucleoTasksStatistics& operator=(NucleoTasksStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NucleoTasksStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NucleoTasksStatistics* internal_default_instance() {
    return reinterpret_cast<const NucleoTasksStatistics*>(
               &_NucleoTasksStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(NucleoTasksStatistics* other);
  friend void swap(NucleoTasksStatistics& a, NucleoTasksStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NucleoTasksStatistics* New() const final {
    return CreateMaybeMessage<NucleoTasksStatistics>(NULL);
  }

  NucleoTasksStatistics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NucleoTasksStatistics>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NucleoTasksStatistics& from);
  void MergeFrom(const NucleoTasksStatistics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NucleoTasksStatistics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.nucleo.statistics.UARTCommTaskStatistics uart_comm = 1;
  bool has_uart_comm() const;
  void clear_uart_comm();
  static const int kUartCommFieldNumber = 1;
  private:
  const ::goldo::nucleo::statistics::UARTCommTaskStatistics& _internal_uart_comm() const;
  public:
  const ::goldo::nucleo::statistics::UARTCommTaskStatistics& uart_comm() const;
  ::goldo::nucleo::statistics::UARTCommTaskStatistics* release_uart_comm();
  ::goldo::nucleo::statistics::UARTCommTaskStatistics* mutable_uart_comm();
  void set_allocated_uart_comm(::goldo::nucleo::statistics::UARTCommTaskStatistics* uart_comm);

  // .goldo.nucleo.statistics.ODriveCommTaskStatistics odrive_comm = 2;
  bool has_odrive_comm() const;
  void clear_odrive_comm();
  static const int kOdriveCommFieldNumber = 2;
  private:
  const ::goldo::nucleo::statistics::ODriveCommTaskStatistics& _internal_odrive_comm() const;
  public:
  const ::goldo::nucleo::statistics::ODriveCommTaskStatistics& odrive_comm() const;
  ::goldo::nucleo::statistics::ODriveCommTaskStatistics* release_odrive_comm();
  ::goldo::nucleo::statistics::ODriveCommTaskStatistics* mutable_odrive_comm();
  void set_allocated_odrive_comm(::goldo::nucleo::statistics::ODriveCommTaskStatistics* odrive_comm);

  // .goldo.nucleo.statistics.PropulsionTaskStatistics propulsion = 3;
  bool has_propulsion() const;
  void clear_propulsion();
  static const int kPropulsionFieldNumber = 3;
  private:
  const ::goldo::nucleo::statistics::PropulsionTaskStatistics& _internal_propulsion() const;
  public:
  const ::goldo::nucleo::statistics::PropulsionTaskStatistics& propulsion() const;
  ::goldo::nucleo::statistics::PropulsionTaskStatistics* release_propulsion();
  ::goldo::nucleo::statistics::PropulsionTaskStatistics* mutable_propulsion();
  void set_allocated_propulsion(::goldo::nucleo::statistics::PropulsionTaskStatistics* propulsion);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.NucleoTasksStatistics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::nucleo::statistics::UARTCommTaskStatistics* uart_comm_;
  ::goldo::nucleo::statistics::ODriveCommTaskStatistics* odrive_comm_;
  ::goldo::nucleo::statistics::PropulsionTaskStatistics* propulsion_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreeRTOSTaskStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.FreeRTOSTaskStats) */ {
 public:
  FreeRTOSTaskStats();
  virtual ~FreeRTOSTaskStats();

  FreeRTOSTaskStats(const FreeRTOSTaskStats& from);

  inline FreeRTOSTaskStats& operator=(const FreeRTOSTaskStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeRTOSTaskStats(FreeRTOSTaskStats&& from) noexcept
    : FreeRTOSTaskStats() {
    *this = ::std::move(from);
  }

  inline FreeRTOSTaskStats& operator=(FreeRTOSTaskStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeRTOSTaskStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeRTOSTaskStats* internal_default_instance() {
    return reinterpret_cast<const FreeRTOSTaskStats*>(
               &_FreeRTOSTaskStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FreeRTOSTaskStats* other);
  friend void swap(FreeRTOSTaskStats& a, FreeRTOSTaskStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeRTOSTaskStats* New() const final {
    return CreateMaybeMessage<FreeRTOSTaskStats>(NULL);
  }

  FreeRTOSTaskStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FreeRTOSTaskStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FreeRTOSTaskStats& from);
  void MergeFrom(const FreeRTOSTaskStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeRTOSTaskStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string task_name = 1;
  void clear_task_name();
  static const int kTaskNameFieldNumber = 1;
  const ::std::string& task_name() const;
  void set_task_name(const ::std::string& value);
  #if LANG_CXX11
  void set_task_name(::std::string&& value);
  #endif
  void set_task_name(const char* value);
  void set_task_name(const char* value, size_t size);
  ::std::string* mutable_task_name();
  ::std::string* release_task_name();
  void set_allocated_task_name(::std::string* task_name);

  // uint32 runtime_counter = 2;
  void clear_runtime_counter();
  static const int kRuntimeCounterFieldNumber = 2;
  ::google::protobuf::uint32 runtime_counter() const;
  void set_runtime_counter(::google::protobuf::uint32 value);

  // uint32 task_number = 3;
  void clear_task_number();
  static const int kTaskNumberFieldNumber = 3;
  ::google::protobuf::uint32 task_number() const;
  void set_task_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.FreeRTOSTaskStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr task_name_;
  ::google::protobuf::uint32 runtime_counter_;
  ::google::protobuf::uint32 task_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreeRTOSTasksStats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.FreeRTOSTasksStats) */ {
 public:
  FreeRTOSTasksStats();
  virtual ~FreeRTOSTasksStats();

  FreeRTOSTasksStats(const FreeRTOSTasksStats& from);

  inline FreeRTOSTasksStats& operator=(const FreeRTOSTasksStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreeRTOSTasksStats(FreeRTOSTasksStats&& from) noexcept
    : FreeRTOSTasksStats() {
    *this = ::std::move(from);
  }

  inline FreeRTOSTasksStats& operator=(FreeRTOSTasksStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreeRTOSTasksStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreeRTOSTasksStats* internal_default_instance() {
    return reinterpret_cast<const FreeRTOSTasksStats*>(
               &_FreeRTOSTasksStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FreeRTOSTasksStats* other);
  friend void swap(FreeRTOSTasksStats& a, FreeRTOSTasksStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreeRTOSTasksStats* New() const final {
    return CreateMaybeMessage<FreeRTOSTasksStats>(NULL);
  }

  FreeRTOSTasksStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FreeRTOSTasksStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FreeRTOSTasksStats& from);
  void MergeFrom(const FreeRTOSTasksStats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreeRTOSTasksStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.nucleo.FreeRTOSTaskStats tasks = 2;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 2;
  ::goldo::nucleo::FreeRTOSTaskStats* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::FreeRTOSTaskStats >*
      mutable_tasks();
  const ::goldo::nucleo::FreeRTOSTaskStats& tasks(int index) const;
  ::goldo::nucleo::FreeRTOSTaskStats* add_tasks();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::FreeRTOSTaskStats >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:goldo.nucleo.FreeRTOSTasksStats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::FreeRTOSTaskStats > tasks_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NucleoState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.NucleoState) */ {
 public:
  NucleoState();
  virtual ~NucleoState();

  NucleoState(const NucleoState& from);

  inline NucleoState& operator=(const NucleoState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NucleoState(NucleoState&& from) noexcept
    : NucleoState() {
    *this = ::std::move(from);
  }

  inline NucleoState& operator=(NucleoState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NucleoState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NucleoState* internal_default_instance() {
    return reinterpret_cast<const NucleoState*>(
               &_NucleoState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NucleoState* other);
  friend void swap(NucleoState& a, NucleoState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NucleoState* New() const final {
    return CreateMaybeMessage<NucleoState>(NULL);
  }

  NucleoState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NucleoState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NucleoState& from);
  void MergeFrom(const NucleoState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NucleoState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.nucleo.NucleoTasksStatistics tasks_statistics = 4;
  bool has_tasks_statistics() const;
  void clear_tasks_statistics();
  static const int kTasksStatisticsFieldNumber = 4;
  private:
  const ::goldo::nucleo::NucleoTasksStatistics& _internal_tasks_statistics() const;
  public:
  const ::goldo::nucleo::NucleoTasksStatistics& tasks_statistics() const;
  ::goldo::nucleo::NucleoTasksStatistics* release_tasks_statistics();
  ::goldo::nucleo::NucleoTasksStatistics* mutable_tasks_statistics();
  void set_allocated_tasks_statistics(::goldo::nucleo::NucleoTasksStatistics* tasks_statistics);

  // .goldo.nucleo.odrive.ODriveStatus odrive = 5;
  bool has_odrive() const;
  void clear_odrive();
  static const int kOdriveFieldNumber = 5;
  private:
  const ::goldo::nucleo::odrive::ODriveStatus& _internal_odrive() const;
  public:
  const ::goldo::nucleo::odrive::ODriveStatus& odrive() const;
  ::goldo::nucleo::odrive::ODriveStatus* release_odrive();
  ::goldo::nucleo::odrive::ODriveStatus* mutable_odrive();
  void set_allocated_odrive(::goldo::nucleo::odrive::ODriveStatus* odrive);

  // .goldo.nucleo.odrive.ClientStatistics odrive_client_statistics = 6;
  bool has_odrive_client_statistics() const;
  void clear_odrive_client_statistics();
  static const int kOdriveClientStatisticsFieldNumber = 6;
  private:
  const ::goldo::nucleo::odrive::ClientStatistics& _internal_odrive_client_statistics() const;
  public:
  const ::goldo::nucleo::odrive::ClientStatistics& odrive_client_statistics() const;
  ::goldo::nucleo::odrive::ClientStatistics* release_odrive_client_statistics();
  ::goldo::nucleo::odrive::ClientStatistics* mutable_odrive_client_statistics();
  void set_allocated_odrive_client_statistics(::goldo::nucleo::odrive::ClientStatistics* odrive_client_statistics);

  // bool connected = 1;
  void clear_connected();
  static const int kConnectedFieldNumber = 1;
  bool connected() const;
  void set_connected(bool value);

  // bool configured = 2;
  void clear_configured();
  static const int kConfiguredFieldNumber = 2;
  bool configured() const;
  void set_configured(bool value);

  // uint32 heartbeat = 3;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 3;
  ::google::protobuf::uint32 heartbeat() const;
  void set_heartbeat(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.NucleoState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::nucleo::NucleoTasksStatistics* tasks_statistics_;
  ::goldo::nucleo::odrive::ODriveStatus* odrive_;
  ::goldo::nucleo::odrive::ClientStatistics* odrive_client_statistics_;
  bool connected_;
  bool configured_;
  ::google::protobuf::uint32 heartbeat_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeChannelConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.ScopeChannelConfig) */ {
 public:
  ScopeChannelConfig();
  virtual ~ScopeChannelConfig();

  ScopeChannelConfig(const ScopeChannelConfig& from);

  inline ScopeChannelConfig& operator=(const ScopeChannelConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeChannelConfig(ScopeChannelConfig&& from) noexcept
    : ScopeChannelConfig() {
    *this = ::std::move(from);
  }

  inline ScopeChannelConfig& operator=(ScopeChannelConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeChannelConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeChannelConfig* internal_default_instance() {
    return reinterpret_cast<const ScopeChannelConfig*>(
               &_ScopeChannelConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ScopeChannelConfig* other);
  friend void swap(ScopeChannelConfig& a, ScopeChannelConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeChannelConfig* New() const final {
    return CreateMaybeMessage<ScopeChannelConfig>(NULL);
  }

  ScopeChannelConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeChannelConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeChannelConfig& from);
  void MergeFrom(const ScopeChannelConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeChannelConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ScopeChannelConfig_Encoding Encoding;
  static const Encoding RAW8 =
    ScopeChannelConfig_Encoding_RAW8;
  static const Encoding RAW16 =
    ScopeChannelConfig_Encoding_RAW16;
  static const Encoding RAW32 =
    ScopeChannelConfig_Encoding_RAW32;
  static const Encoding SCALED8 =
    ScopeChannelConfig_Encoding_SCALED8;
  static const Encoding SCALED16 =
    ScopeChannelConfig_Encoding_SCALED16;
  static const Encoding SCALED32 =
    ScopeChannelConfig_Encoding_SCALED32;
  static const Encoding FLOAT32 =
    ScopeChannelConfig_Encoding_FLOAT32;
  static inline bool Encoding_IsValid(int value) {
    return ScopeChannelConfig_Encoding_IsValid(value);
  }
  static const Encoding Encoding_MIN =
    ScopeChannelConfig_Encoding_Encoding_MIN;
  static const Encoding Encoding_MAX =
    ScopeChannelConfig_Encoding_Encoding_MAX;
  static const int Encoding_ARRAYSIZE =
    ScopeChannelConfig_Encoding_Encoding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Encoding_descriptor() {
    return ScopeChannelConfig_Encoding_descriptor();
  }
  static inline const ::std::string& Encoding_Name(Encoding value) {
    return ScopeChannelConfig_Encoding_Name(value);
  }
  static inline bool Encoding_Parse(const ::std::string& name,
      Encoding* value) {
    return ScopeChannelConfig_Encoding_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // uint32 variable = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  ::google::protobuf::uint32 variable() const;
  void set_variable(::google::protobuf::uint32 value);

  // uint32 encoding = 2 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_encoding();
  static const int kEncodingFieldNumber = 2;
  ::google::protobuf::uint32 encoding() const;
  void set_encoding(::google::protobuf::uint32 value);

  // float min_value = 3;
  void clear_min_value();
  static const int kMinValueFieldNumber = 3;
  float min_value() const;
  void set_min_value(float value);

  // float max_value = 4;
  void clear_max_value();
  static const int kMaxValueFieldNumber = 4;
  float max_value() const;
  void set_max_value(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.ScopeChannelConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 variable_;
  ::google::protobuf::uint32 encoding_;
  float min_value_;
  float max_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.ScopeConfig) */ {
 public:
  ScopeConfig();
  virtual ~ScopeConfig();

  ScopeConfig(const ScopeConfig& from);

  inline ScopeConfig& operator=(const ScopeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeConfig(ScopeConfig&& from) noexcept
    : ScopeConfig() {
    *this = ::std::move(from);
  }

  inline ScopeConfig& operator=(ScopeConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeConfig* internal_default_instance() {
    return reinterpret_cast<const ScopeConfig*>(
               &_ScopeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ScopeConfig* other);
  friend void swap(ScopeConfig& a, ScopeConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeConfig* New() const final {
    return CreateMaybeMessage<ScopeConfig>(NULL);
  }

  ScopeConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeConfig& from);
  void MergeFrom(const ScopeConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.nucleo.ScopeChannelConfig channels = 2 [(.goldo.pb2_options.max_count) = 8, (.goldo.pb2_options.count_type) = UINT16];
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::goldo::nucleo::ScopeChannelConfig* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelConfig >*
      mutable_channels();
  const ::goldo::nucleo::ScopeChannelConfig& channels(int index) const;
  ::goldo::nucleo::ScopeChannelConfig* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelConfig >&
      channels() const;

  // uint32 period = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_period();
  static const int kPeriodFieldNumber = 1;
  ::google::protobuf::uint32 period() const;
  void set_period(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.ScopeConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelConfig > channels_;
  ::google::protobuf::uint32 period_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.ScopeData) */ {
 public:
  ScopeData();
  virtual ~ScopeData();

  ScopeData(const ScopeData& from);

  inline ScopeData& operator=(const ScopeData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeData(ScopeData&& from) noexcept
    : ScopeData() {
    *this = ::std::move(from);
  }

  inline ScopeData& operator=(ScopeData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeData* internal_default_instance() {
    return reinterpret_cast<const ScopeData*>(
               &_ScopeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ScopeData* other);
  friend void swap(ScopeData& a, ScopeData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeData* New() const final {
    return CreateMaybeMessage<ScopeData>(NULL);
  }

  ScopeData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeData& from);
  void MergeFrom(const ScopeData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.ScopeData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeChannelValues : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.ScopeChannelValues) */ {
 public:
  ScopeChannelValues();
  virtual ~ScopeChannelValues();

  ScopeChannelValues(const ScopeChannelValues& from);

  inline ScopeChannelValues& operator=(const ScopeChannelValues& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeChannelValues(ScopeChannelValues&& from) noexcept
    : ScopeChannelValues() {
    *this = ::std::move(from);
  }

  inline ScopeChannelValues& operator=(ScopeChannelValues&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeChannelValues& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeChannelValues* internal_default_instance() {
    return reinterpret_cast<const ScopeChannelValues*>(
               &_ScopeChannelValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ScopeChannelValues* other);
  friend void swap(ScopeChannelValues& a, ScopeChannelValues& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeChannelValues* New() const final {
    return CreateMaybeMessage<ScopeChannelValues>(NULL);
  }

  ScopeChannelValues* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeChannelValues>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeChannelValues& from);
  void MergeFrom(const ScopeChannelValues& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeChannelValues* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float float_values = 1;
  int float_values_size() const;
  void clear_float_values();
  static const int kFloatValuesFieldNumber = 1;
  float float_values(int index) const;
  void set_float_values(int index, float value);
  void add_float_values(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_values() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_values();

  // @@protoc_insertion_point(class_scope:goldo.nucleo.ScopeChannelValues)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > float_values_;
  mutable int _float_values_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScopeValues : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.ScopeValues) */ {
 public:
  ScopeValues();
  virtual ~ScopeValues();

  ScopeValues(const ScopeValues& from);

  inline ScopeValues& operator=(const ScopeValues& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScopeValues(ScopeValues&& from) noexcept
    : ScopeValues() {
    *this = ::std::move(from);
  }

  inline ScopeValues& operator=(ScopeValues&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScopeValues& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScopeValues* internal_default_instance() {
    return reinterpret_cast<const ScopeValues*>(
               &_ScopeValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ScopeValues* other);
  friend void swap(ScopeValues& a, ScopeValues& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScopeValues* New() const final {
    return CreateMaybeMessage<ScopeValues>(NULL);
  }

  ScopeValues* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScopeValues>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScopeValues& from);
  void MergeFrom(const ScopeValues& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScopeValues* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float timestamps = 1;
  int timestamps_size() const;
  void clear_timestamps();
  static const int kTimestampsFieldNumber = 1;
  float timestamps(int index) const;
  void set_timestamps(int index, float value);
  void add_timestamps(float value);
  const ::google::protobuf::RepeatedField< float >&
      timestamps() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_timestamps();

  // repeated .goldo.nucleo.ScopeChannelValues channels = 2;
  int channels_size() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::goldo::nucleo::ScopeChannelValues* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelValues >*
      mutable_channels();
  const ::goldo::nucleo::ScopeChannelValues& channels(int index) const;
  ::goldo::nucleo::ScopeChannelValues* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelValues >&
      channels() const;

  // @@protoc_insertion_point(class_scope:goldo.nucleo.ScopeValues)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > timestamps_;
  mutable int _timestamps_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelValues > channels_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SensorConfig

// .goldo.nucleo.SensorType type = 1 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void SensorConfig::clear_type() {
  type_ = 0;
}
inline ::goldo::nucleo::SensorType SensorConfig::type() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.SensorConfig.type)
  return static_cast< ::goldo::nucleo::SensorType >(type_);
}
inline void SensorConfig::set_type(::goldo::nucleo::SensorType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.SensorConfig.type)
}

// int32 id = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void SensorConfig::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SensorConfig::id() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.SensorConfig.id)
  return id_;
}
inline void SensorConfig::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.SensorConfig.id)
}

// string name = 64 [(.goldo.pb2_options.cpp_type) = VOID];
inline void SensorConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SensorConfig::name() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.SensorConfig.name)
  return name_.GetNoArena();
}
inline void SensorConfig::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.nucleo.SensorConfig.name)
}
#if LANG_CXX11
inline void SensorConfig::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.nucleo.SensorConfig.name)
}
#endif
inline void SensorConfig::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.nucleo.SensorConfig.name)
}
inline void SensorConfig::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.nucleo.SensorConfig.name)
}
inline ::std::string* SensorConfig::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.SensorConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorConfig::release_name() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.SensorConfig.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.SensorConfig.name)
}

// -------------------------------------------------------------------

// NucleoConfig

// .goldo.nucleo.hal.HalConfig hal = 1;
inline bool NucleoConfig::has_hal() const {
  return this != internal_default_instance() && hal_ != NULL;
}
inline const ::goldo::nucleo::hal::HalConfig& NucleoConfig::_internal_hal() const {
  return *hal_;
}
inline const ::goldo::nucleo::hal::HalConfig& NucleoConfig::hal() const {
  const ::goldo::nucleo::hal::HalConfig* p = hal_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.hal)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::hal::HalConfig*>(
      &::goldo::nucleo::hal::_HalConfig_default_instance_);
}
inline ::goldo::nucleo::hal::HalConfig* NucleoConfig::release_hal() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoConfig.hal)
  
  ::goldo::nucleo::hal::HalConfig* temp = hal_;
  hal_ = NULL;
  return temp;
}
inline ::goldo::nucleo::hal::HalConfig* NucleoConfig::mutable_hal() {
  
  if (hal_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::hal::HalConfig>(GetArenaNoVirtual());
    hal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.hal)
  return hal_;
}
inline void NucleoConfig::set_allocated_hal(::goldo::nucleo::hal::HalConfig* hal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hal_);
  }
  if (hal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hal, submessage_arena);
    }
    
  } else {
    
  }
  hal_ = hal;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoConfig.hal)
}

// .goldo.nucleo.robot_simulator.RobotSimulatorConfig robot_simulator = 2;
inline bool NucleoConfig::has_robot_simulator() const {
  return this != internal_default_instance() && robot_simulator_ != NULL;
}
inline const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig& NucleoConfig::_internal_robot_simulator() const {
  return *robot_simulator_;
}
inline const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig& NucleoConfig::robot_simulator() const {
  const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* p = robot_simulator_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.robot_simulator)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::robot_simulator::RobotSimulatorConfig*>(
      &::goldo::nucleo::robot_simulator::_RobotSimulatorConfig_default_instance_);
}
inline ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* NucleoConfig::release_robot_simulator() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoConfig.robot_simulator)
  
  ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* temp = robot_simulator_;
  robot_simulator_ = NULL;
  return temp;
}
inline ::goldo::nucleo::robot_simulator::RobotSimulatorConfig* NucleoConfig::mutable_robot_simulator() {
  
  if (robot_simulator_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::robot_simulator::RobotSimulatorConfig>(GetArenaNoVirtual());
    robot_simulator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.robot_simulator)
  return robot_simulator_;
}
inline void NucleoConfig::set_allocated_robot_simulator(::goldo::nucleo::robot_simulator::RobotSimulatorConfig* robot_simulator) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(robot_simulator_);
  }
  if (robot_simulator) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot_simulator = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_simulator, submessage_arena);
    }
    
  } else {
    
  }
  robot_simulator_ = robot_simulator;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoConfig.robot_simulator)
}

// .goldo.nucleo.odometry.OdometryConfig odometry = 3;
inline bool NucleoConfig::has_odometry() const {
  return this != internal_default_instance() && odometry_ != NULL;
}
inline const ::goldo::nucleo::odometry::OdometryConfig& NucleoConfig::_internal_odometry() const {
  return *odometry_;
}
inline const ::goldo::nucleo::odometry::OdometryConfig& NucleoConfig::odometry() const {
  const ::goldo::nucleo::odometry::OdometryConfig* p = odometry_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.odometry)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::odometry::OdometryConfig*>(
      &::goldo::nucleo::odometry::_OdometryConfig_default_instance_);
}
inline ::goldo::nucleo::odometry::OdometryConfig* NucleoConfig::release_odometry() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoConfig.odometry)
  
  ::goldo::nucleo::odometry::OdometryConfig* temp = odometry_;
  odometry_ = NULL;
  return temp;
}
inline ::goldo::nucleo::odometry::OdometryConfig* NucleoConfig::mutable_odometry() {
  
  if (odometry_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::odometry::OdometryConfig>(GetArenaNoVirtual());
    odometry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.odometry)
  return odometry_;
}
inline void NucleoConfig::set_allocated_odometry(::goldo::nucleo::odometry::OdometryConfig* odometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odometry_);
  }
  if (odometry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odometry, submessage_arena);
    }
    
  } else {
    
  }
  odometry_ = odometry;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoConfig.odometry)
}

// .goldo.nucleo.propulsion.PropulsionControllerConfig propulsion = 4;
inline bool NucleoConfig::has_propulsion() const {
  return this != internal_default_instance() && propulsion_ != NULL;
}
inline const ::goldo::nucleo::propulsion::PropulsionControllerConfig& NucleoConfig::_internal_propulsion() const {
  return *propulsion_;
}
inline const ::goldo::nucleo::propulsion::PropulsionControllerConfig& NucleoConfig::propulsion() const {
  const ::goldo::nucleo::propulsion::PropulsionControllerConfig* p = propulsion_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.propulsion)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PropulsionControllerConfig*>(
      &::goldo::nucleo::propulsion::_PropulsionControllerConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PropulsionControllerConfig* NucleoConfig::release_propulsion() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoConfig.propulsion)
  
  ::goldo::nucleo::propulsion::PropulsionControllerConfig* temp = propulsion_;
  propulsion_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PropulsionControllerConfig* NucleoConfig::mutable_propulsion() {
  
  if (propulsion_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionControllerConfig>(GetArenaNoVirtual());
    propulsion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.propulsion)
  return propulsion_;
}
inline void NucleoConfig::set_allocated_propulsion(::goldo::nucleo::propulsion::PropulsionControllerConfig* propulsion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(propulsion_);
  }
  if (propulsion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      propulsion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, propulsion, submessage_arena);
    }
    
  } else {
    
  }
  propulsion_ = propulsion;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoConfig.propulsion)
}

// .goldo.nucleo.propulsion.PropulsionTaskConfig propulsion_task = 5;
inline bool NucleoConfig::has_propulsion_task() const {
  return this != internal_default_instance() && propulsion_task_ != NULL;
}
inline const ::goldo::nucleo::propulsion::PropulsionTaskConfig& NucleoConfig::_internal_propulsion_task() const {
  return *propulsion_task_;
}
inline const ::goldo::nucleo::propulsion::PropulsionTaskConfig& NucleoConfig::propulsion_task() const {
  const ::goldo::nucleo::propulsion::PropulsionTaskConfig* p = propulsion_task_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.propulsion_task)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PropulsionTaskConfig*>(
      &::goldo::nucleo::propulsion::_PropulsionTaskConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PropulsionTaskConfig* NucleoConfig::release_propulsion_task() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoConfig.propulsion_task)
  
  ::goldo::nucleo::propulsion::PropulsionTaskConfig* temp = propulsion_task_;
  propulsion_task_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PropulsionTaskConfig* NucleoConfig::mutable_propulsion_task() {
  
  if (propulsion_task_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionTaskConfig>(GetArenaNoVirtual());
    propulsion_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.propulsion_task)
  return propulsion_task_;
}
inline void NucleoConfig::set_allocated_propulsion_task(::goldo::nucleo::propulsion::PropulsionTaskConfig* propulsion_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(propulsion_task_);
  }
  if (propulsion_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      propulsion_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, propulsion_task, submessage_arena);
    }
    
  } else {
    
  }
  propulsion_task_ = propulsion_task;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoConfig.propulsion_task)
}

// repeated .goldo.nucleo.servos.ServoConfig servos = 6;
inline int NucleoConfig::servos_size() const {
  return servos_.size();
}
inline ::goldo::nucleo::servos::ServoConfig* NucleoConfig::mutable_servos(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.servos)
  return servos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::ServoConfig >*
NucleoConfig::mutable_servos() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.NucleoConfig.servos)
  return &servos_;
}
inline const ::goldo::nucleo::servos::ServoConfig& NucleoConfig::servos(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.servos)
  return servos_.Get(index);
}
inline ::goldo::nucleo::servos::ServoConfig* NucleoConfig::add_servos() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.NucleoConfig.servos)
  return servos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::ServoConfig >&
NucleoConfig::servos() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.NucleoConfig.servos)
  return servos_;
}

// repeated .goldo.nucleo.SensorConfig sensors = 7;
inline int NucleoConfig::sensors_size() const {
  return sensors_.size();
}
inline void NucleoConfig::clear_sensors() {
  sensors_.Clear();
}
inline ::goldo::nucleo::SensorConfig* NucleoConfig::mutable_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.sensors)
  return sensors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::SensorConfig >*
NucleoConfig::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.NucleoConfig.sensors)
  return &sensors_;
}
inline const ::goldo::nucleo::SensorConfig& NucleoConfig::sensors(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.sensors)
  return sensors_.Get(index);
}
inline ::goldo::nucleo::SensorConfig* NucleoConfig::add_sensors() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.NucleoConfig.sensors)
  return sensors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::SensorConfig >&
NucleoConfig::sensors() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.NucleoConfig.sensors)
  return sensors_;
}

// repeated string enabled_tasks = 8;
inline int NucleoConfig::enabled_tasks_size() const {
  return enabled_tasks_.size();
}
inline void NucleoConfig::clear_enabled_tasks() {
  enabled_tasks_.Clear();
}
inline const ::std::string& NucleoConfig::enabled_tasks(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.enabled_tasks)
  return enabled_tasks_.Get(index);
}
inline ::std::string* NucleoConfig::mutable_enabled_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.enabled_tasks)
  return enabled_tasks_.Mutable(index);
}
inline void NucleoConfig::set_enabled_tasks(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoConfig.enabled_tasks)
  enabled_tasks_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NucleoConfig::set_enabled_tasks(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoConfig.enabled_tasks)
  enabled_tasks_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NucleoConfig::set_enabled_tasks(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  enabled_tasks_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:goldo.nucleo.NucleoConfig.enabled_tasks)
}
inline void NucleoConfig::set_enabled_tasks(int index, const char* value, size_t size) {
  enabled_tasks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:goldo.nucleo.NucleoConfig.enabled_tasks)
}
inline ::std::string* NucleoConfig::add_enabled_tasks() {
  // @@protoc_insertion_point(field_add_mutable:goldo.nucleo.NucleoConfig.enabled_tasks)
  return enabled_tasks_.Add();
}
inline void NucleoConfig::add_enabled_tasks(const ::std::string& value) {
  enabled_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:goldo.nucleo.NucleoConfig.enabled_tasks)
}
#if LANG_CXX11
inline void NucleoConfig::add_enabled_tasks(::std::string&& value) {
  enabled_tasks_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:goldo.nucleo.NucleoConfig.enabled_tasks)
}
#endif
inline void NucleoConfig::add_enabled_tasks(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  enabled_tasks_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:goldo.nucleo.NucleoConfig.enabled_tasks)
}
inline void NucleoConfig::add_enabled_tasks(const char* value, size_t size) {
  enabled_tasks_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:goldo.nucleo.NucleoConfig.enabled_tasks)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NucleoConfig::enabled_tasks() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.NucleoConfig.enabled_tasks)
  return enabled_tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NucleoConfig::mutable_enabled_tasks() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.NucleoConfig.enabled_tasks)
  return &enabled_tasks_;
}

// repeated .goldo.nucleo.servos.LiftConfig lifts = 9;
inline int NucleoConfig::lifts_size() const {
  return lifts_.size();
}
inline ::goldo::nucleo::servos::LiftConfig* NucleoConfig::mutable_lifts(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoConfig.lifts)
  return lifts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::LiftConfig >*
NucleoConfig::mutable_lifts() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.NucleoConfig.lifts)
  return &lifts_;
}
inline const ::goldo::nucleo::servos::LiftConfig& NucleoConfig::lifts(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoConfig.lifts)
  return lifts_.Get(index);
}
inline ::goldo::nucleo::servos::LiftConfig* NucleoConfig::add_lifts() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.NucleoConfig.lifts)
  return lifts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::servos::LiftConfig >&
NucleoConfig::lifts() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.NucleoConfig.lifts)
  return lifts_;
}

// -------------------------------------------------------------------

// NucleoTasksState

// bool comm_uart = 1;
inline void NucleoTasksState::clear_comm_uart() {
  comm_uart_ = false;
}
inline bool NucleoTasksState::comm_uart() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoTasksState.comm_uart)
  return comm_uart_;
}
inline void NucleoTasksState::set_comm_uart(bool value) {
  
  comm_uart_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoTasksState.comm_uart)
}

// -------------------------------------------------------------------

// NucleoTasksStatistics

// .goldo.nucleo.statistics.UARTCommTaskStatistics uart_comm = 1;
inline bool NucleoTasksStatistics::has_uart_comm() const {
  return this != internal_default_instance() && uart_comm_ != NULL;
}
inline const ::goldo::nucleo::statistics::UARTCommTaskStatistics& NucleoTasksStatistics::_internal_uart_comm() const {
  return *uart_comm_;
}
inline const ::goldo::nucleo::statistics::UARTCommTaskStatistics& NucleoTasksStatistics::uart_comm() const {
  const ::goldo::nucleo::statistics::UARTCommTaskStatistics* p = uart_comm_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoTasksStatistics.uart_comm)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::statistics::UARTCommTaskStatistics*>(
      &::goldo::nucleo::statistics::_UARTCommTaskStatistics_default_instance_);
}
inline ::goldo::nucleo::statistics::UARTCommTaskStatistics* NucleoTasksStatistics::release_uart_comm() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoTasksStatistics.uart_comm)
  
  ::goldo::nucleo::statistics::UARTCommTaskStatistics* temp = uart_comm_;
  uart_comm_ = NULL;
  return temp;
}
inline ::goldo::nucleo::statistics::UARTCommTaskStatistics* NucleoTasksStatistics::mutable_uart_comm() {
  
  if (uart_comm_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::statistics::UARTCommTaskStatistics>(GetArenaNoVirtual());
    uart_comm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoTasksStatistics.uart_comm)
  return uart_comm_;
}
inline void NucleoTasksStatistics::set_allocated_uart_comm(::goldo::nucleo::statistics::UARTCommTaskStatistics* uart_comm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(uart_comm_);
  }
  if (uart_comm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uart_comm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uart_comm, submessage_arena);
    }
    
  } else {
    
  }
  uart_comm_ = uart_comm;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoTasksStatistics.uart_comm)
}

// .goldo.nucleo.statistics.ODriveCommTaskStatistics odrive_comm = 2;
inline bool NucleoTasksStatistics::has_odrive_comm() const {
  return this != internal_default_instance() && odrive_comm_ != NULL;
}
inline const ::goldo::nucleo::statistics::ODriveCommTaskStatistics& NucleoTasksStatistics::_internal_odrive_comm() const {
  return *odrive_comm_;
}
inline const ::goldo::nucleo::statistics::ODriveCommTaskStatistics& NucleoTasksStatistics::odrive_comm() const {
  const ::goldo::nucleo::statistics::ODriveCommTaskStatistics* p = odrive_comm_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoTasksStatistics.odrive_comm)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::statistics::ODriveCommTaskStatistics*>(
      &::goldo::nucleo::statistics::_ODriveCommTaskStatistics_default_instance_);
}
inline ::goldo::nucleo::statistics::ODriveCommTaskStatistics* NucleoTasksStatistics::release_odrive_comm() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoTasksStatistics.odrive_comm)
  
  ::goldo::nucleo::statistics::ODriveCommTaskStatistics* temp = odrive_comm_;
  odrive_comm_ = NULL;
  return temp;
}
inline ::goldo::nucleo::statistics::ODriveCommTaskStatistics* NucleoTasksStatistics::mutable_odrive_comm() {
  
  if (odrive_comm_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::statistics::ODriveCommTaskStatistics>(GetArenaNoVirtual());
    odrive_comm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoTasksStatistics.odrive_comm)
  return odrive_comm_;
}
inline void NucleoTasksStatistics::set_allocated_odrive_comm(::goldo::nucleo::statistics::ODriveCommTaskStatistics* odrive_comm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odrive_comm_);
  }
  if (odrive_comm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odrive_comm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odrive_comm, submessage_arena);
    }
    
  } else {
    
  }
  odrive_comm_ = odrive_comm;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoTasksStatistics.odrive_comm)
}

// .goldo.nucleo.statistics.PropulsionTaskStatistics propulsion = 3;
inline bool NucleoTasksStatistics::has_propulsion() const {
  return this != internal_default_instance() && propulsion_ != NULL;
}
inline const ::goldo::nucleo::statistics::PropulsionTaskStatistics& NucleoTasksStatistics::_internal_propulsion() const {
  return *propulsion_;
}
inline const ::goldo::nucleo::statistics::PropulsionTaskStatistics& NucleoTasksStatistics::propulsion() const {
  const ::goldo::nucleo::statistics::PropulsionTaskStatistics* p = propulsion_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoTasksStatistics.propulsion)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::statistics::PropulsionTaskStatistics*>(
      &::goldo::nucleo::statistics::_PropulsionTaskStatistics_default_instance_);
}
inline ::goldo::nucleo::statistics::PropulsionTaskStatistics* NucleoTasksStatistics::release_propulsion() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoTasksStatistics.propulsion)
  
  ::goldo::nucleo::statistics::PropulsionTaskStatistics* temp = propulsion_;
  propulsion_ = NULL;
  return temp;
}
inline ::goldo::nucleo::statistics::PropulsionTaskStatistics* NucleoTasksStatistics::mutable_propulsion() {
  
  if (propulsion_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::statistics::PropulsionTaskStatistics>(GetArenaNoVirtual());
    propulsion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoTasksStatistics.propulsion)
  return propulsion_;
}
inline void NucleoTasksStatistics::set_allocated_propulsion(::goldo::nucleo::statistics::PropulsionTaskStatistics* propulsion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(propulsion_);
  }
  if (propulsion) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      propulsion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, propulsion, submessage_arena);
    }
    
  } else {
    
  }
  propulsion_ = propulsion;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoTasksStatistics.propulsion)
}

// -------------------------------------------------------------------

// FreeRTOSTaskStats

// string task_name = 1;
inline void FreeRTOSTaskStats::clear_task_name() {
  task_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FreeRTOSTaskStats::task_name() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.FreeRTOSTaskStats.task_name)
  return task_name_.GetNoArena();
}
inline void FreeRTOSTaskStats::set_task_name(const ::std::string& value) {
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.nucleo.FreeRTOSTaskStats.task_name)
}
#if LANG_CXX11
inline void FreeRTOSTaskStats::set_task_name(::std::string&& value) {
  
  task_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.nucleo.FreeRTOSTaskStats.task_name)
}
#endif
inline void FreeRTOSTaskStats::set_task_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.nucleo.FreeRTOSTaskStats.task_name)
}
inline void FreeRTOSTaskStats::set_task_name(const char* value, size_t size) {
  
  task_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.nucleo.FreeRTOSTaskStats.task_name)
}
inline ::std::string* FreeRTOSTaskStats::mutable_task_name() {
  
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.FreeRTOSTaskStats.task_name)
  return task_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FreeRTOSTaskStats::release_task_name() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.FreeRTOSTaskStats.task_name)
  
  return task_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FreeRTOSTaskStats::set_allocated_task_name(::std::string* task_name) {
  if (task_name != NULL) {
    
  } else {
    
  }
  task_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_name);
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.FreeRTOSTaskStats.task_name)
}

// uint32 runtime_counter = 2;
inline void FreeRTOSTaskStats::clear_runtime_counter() {
  runtime_counter_ = 0u;
}
inline ::google::protobuf::uint32 FreeRTOSTaskStats::runtime_counter() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.FreeRTOSTaskStats.runtime_counter)
  return runtime_counter_;
}
inline void FreeRTOSTaskStats::set_runtime_counter(::google::protobuf::uint32 value) {
  
  runtime_counter_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.FreeRTOSTaskStats.runtime_counter)
}

// uint32 task_number = 3;
inline void FreeRTOSTaskStats::clear_task_number() {
  task_number_ = 0u;
}
inline ::google::protobuf::uint32 FreeRTOSTaskStats::task_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.FreeRTOSTaskStats.task_number)
  return task_number_;
}
inline void FreeRTOSTaskStats::set_task_number(::google::protobuf::uint32 value) {
  
  task_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.FreeRTOSTaskStats.task_number)
}

// -------------------------------------------------------------------

// FreeRTOSTasksStats

// repeated .goldo.nucleo.FreeRTOSTaskStats tasks = 2;
inline int FreeRTOSTasksStats::tasks_size() const {
  return tasks_.size();
}
inline void FreeRTOSTasksStats::clear_tasks() {
  tasks_.Clear();
}
inline ::goldo::nucleo::FreeRTOSTaskStats* FreeRTOSTasksStats::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.FreeRTOSTasksStats.tasks)
  return tasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::FreeRTOSTaskStats >*
FreeRTOSTasksStats::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.FreeRTOSTasksStats.tasks)
  return &tasks_;
}
inline const ::goldo::nucleo::FreeRTOSTaskStats& FreeRTOSTasksStats::tasks(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.FreeRTOSTasksStats.tasks)
  return tasks_.Get(index);
}
inline ::goldo::nucleo::FreeRTOSTaskStats* FreeRTOSTasksStats::add_tasks() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.FreeRTOSTasksStats.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::FreeRTOSTaskStats >&
FreeRTOSTasksStats::tasks() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.FreeRTOSTasksStats.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// NucleoState

// bool connected = 1;
inline void NucleoState::clear_connected() {
  connected_ = false;
}
inline bool NucleoState::connected() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.connected)
  return connected_;
}
inline void NucleoState::set_connected(bool value) {
  
  connected_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoState.connected)
}

// bool configured = 2;
inline void NucleoState::clear_configured() {
  configured_ = false;
}
inline bool NucleoState::configured() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.configured)
  return configured_;
}
inline void NucleoState::set_configured(bool value) {
  
  configured_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoState.configured)
}

// uint32 heartbeat = 3;
inline void NucleoState::clear_heartbeat() {
  heartbeat_ = 0u;
}
inline ::google::protobuf::uint32 NucleoState::heartbeat() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.heartbeat)
  return heartbeat_;
}
inline void NucleoState::set_heartbeat(::google::protobuf::uint32 value) {
  
  heartbeat_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.NucleoState.heartbeat)
}

// .goldo.nucleo.NucleoTasksStatistics tasks_statistics = 4;
inline bool NucleoState::has_tasks_statistics() const {
  return this != internal_default_instance() && tasks_statistics_ != NULL;
}
inline void NucleoState::clear_tasks_statistics() {
  if (GetArenaNoVirtual() == NULL && tasks_statistics_ != NULL) {
    delete tasks_statistics_;
  }
  tasks_statistics_ = NULL;
}
inline const ::goldo::nucleo::NucleoTasksStatistics& NucleoState::_internal_tasks_statistics() const {
  return *tasks_statistics_;
}
inline const ::goldo::nucleo::NucleoTasksStatistics& NucleoState::tasks_statistics() const {
  const ::goldo::nucleo::NucleoTasksStatistics* p = tasks_statistics_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.tasks_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::NucleoTasksStatistics*>(
      &::goldo::nucleo::_NucleoTasksStatistics_default_instance_);
}
inline ::goldo::nucleo::NucleoTasksStatistics* NucleoState::release_tasks_statistics() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoState.tasks_statistics)
  
  ::goldo::nucleo::NucleoTasksStatistics* temp = tasks_statistics_;
  tasks_statistics_ = NULL;
  return temp;
}
inline ::goldo::nucleo::NucleoTasksStatistics* NucleoState::mutable_tasks_statistics() {
  
  if (tasks_statistics_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::NucleoTasksStatistics>(GetArenaNoVirtual());
    tasks_statistics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoState.tasks_statistics)
  return tasks_statistics_;
}
inline void NucleoState::set_allocated_tasks_statistics(::goldo::nucleo::NucleoTasksStatistics* tasks_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tasks_statistics_;
  }
  if (tasks_statistics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tasks_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tasks_statistics, submessage_arena);
    }
    
  } else {
    
  }
  tasks_statistics_ = tasks_statistics;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoState.tasks_statistics)
}

// .goldo.nucleo.odrive.ODriveStatus odrive = 5;
inline bool NucleoState::has_odrive() const {
  return this != internal_default_instance() && odrive_ != NULL;
}
inline const ::goldo::nucleo::odrive::ODriveStatus& NucleoState::_internal_odrive() const {
  return *odrive_;
}
inline const ::goldo::nucleo::odrive::ODriveStatus& NucleoState::odrive() const {
  const ::goldo::nucleo::odrive::ODriveStatus* p = odrive_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.odrive)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::odrive::ODriveStatus*>(
      &::goldo::nucleo::odrive::_ODriveStatus_default_instance_);
}
inline ::goldo::nucleo::odrive::ODriveStatus* NucleoState::release_odrive() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoState.odrive)
  
  ::goldo::nucleo::odrive::ODriveStatus* temp = odrive_;
  odrive_ = NULL;
  return temp;
}
inline ::goldo::nucleo::odrive::ODriveStatus* NucleoState::mutable_odrive() {
  
  if (odrive_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::odrive::ODriveStatus>(GetArenaNoVirtual());
    odrive_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoState.odrive)
  return odrive_;
}
inline void NucleoState::set_allocated_odrive(::goldo::nucleo::odrive::ODriveStatus* odrive) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odrive_);
  }
  if (odrive) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odrive = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odrive, submessage_arena);
    }
    
  } else {
    
  }
  odrive_ = odrive;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoState.odrive)
}

// .goldo.nucleo.odrive.ClientStatistics odrive_client_statistics = 6;
inline bool NucleoState::has_odrive_client_statistics() const {
  return this != internal_default_instance() && odrive_client_statistics_ != NULL;
}
inline const ::goldo::nucleo::odrive::ClientStatistics& NucleoState::_internal_odrive_client_statistics() const {
  return *odrive_client_statistics_;
}
inline const ::goldo::nucleo::odrive::ClientStatistics& NucleoState::odrive_client_statistics() const {
  const ::goldo::nucleo::odrive::ClientStatistics* p = odrive_client_statistics_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.NucleoState.odrive_client_statistics)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::odrive::ClientStatistics*>(
      &::goldo::nucleo::odrive::_ClientStatistics_default_instance_);
}
inline ::goldo::nucleo::odrive::ClientStatistics* NucleoState::release_odrive_client_statistics() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.NucleoState.odrive_client_statistics)
  
  ::goldo::nucleo::odrive::ClientStatistics* temp = odrive_client_statistics_;
  odrive_client_statistics_ = NULL;
  return temp;
}
inline ::goldo::nucleo::odrive::ClientStatistics* NucleoState::mutable_odrive_client_statistics() {
  
  if (odrive_client_statistics_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::odrive::ClientStatistics>(GetArenaNoVirtual());
    odrive_client_statistics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.NucleoState.odrive_client_statistics)
  return odrive_client_statistics_;
}
inline void NucleoState::set_allocated_odrive_client_statistics(::goldo::nucleo::odrive::ClientStatistics* odrive_client_statistics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(odrive_client_statistics_);
  }
  if (odrive_client_statistics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      odrive_client_statistics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, odrive_client_statistics, submessage_arena);
    }
    
  } else {
    
  }
  odrive_client_statistics_ = odrive_client_statistics;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.NucleoState.odrive_client_statistics)
}

// -------------------------------------------------------------------

// ScopeChannelConfig

// uint32 variable = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ScopeChannelConfig::clear_variable() {
  variable_ = 0u;
}
inline ::google::protobuf::uint32 ScopeChannelConfig::variable() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeChannelConfig.variable)
  return variable_;
}
inline void ScopeChannelConfig::set_variable(::google::protobuf::uint32 value) {
  
  variable_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeChannelConfig.variable)
}

// uint32 encoding = 2 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ScopeChannelConfig::clear_encoding() {
  encoding_ = 0u;
}
inline ::google::protobuf::uint32 ScopeChannelConfig::encoding() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeChannelConfig.encoding)
  return encoding_;
}
inline void ScopeChannelConfig::set_encoding(::google::protobuf::uint32 value) {
  
  encoding_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeChannelConfig.encoding)
}

// float min_value = 3;
inline void ScopeChannelConfig::clear_min_value() {
  min_value_ = 0;
}
inline float ScopeChannelConfig::min_value() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeChannelConfig.min_value)
  return min_value_;
}
inline void ScopeChannelConfig::set_min_value(float value) {
  
  min_value_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeChannelConfig.min_value)
}

// float max_value = 4;
inline void ScopeChannelConfig::clear_max_value() {
  max_value_ = 0;
}
inline float ScopeChannelConfig::max_value() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeChannelConfig.max_value)
  return max_value_;
}
inline void ScopeChannelConfig::set_max_value(float value) {
  
  max_value_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeChannelConfig.max_value)
}

// -------------------------------------------------------------------

// ScopeConfig

// uint32 period = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ScopeConfig::clear_period() {
  period_ = 0u;
}
inline ::google::protobuf::uint32 ScopeConfig::period() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeConfig.period)
  return period_;
}
inline void ScopeConfig::set_period(::google::protobuf::uint32 value) {
  
  period_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeConfig.period)
}

// repeated .goldo.nucleo.ScopeChannelConfig channels = 2 [(.goldo.pb2_options.max_count) = 8, (.goldo.pb2_options.count_type) = UINT16];
inline int ScopeConfig::channels_size() const {
  return channels_.size();
}
inline void ScopeConfig::clear_channels() {
  channels_.Clear();
}
inline ::goldo::nucleo::ScopeChannelConfig* ScopeConfig::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.ScopeConfig.channels)
  return channels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelConfig >*
ScopeConfig::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.ScopeConfig.channels)
  return &channels_;
}
inline const ::goldo::nucleo::ScopeChannelConfig& ScopeConfig::channels(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeConfig.channels)
  return channels_.Get(index);
}
inline ::goldo::nucleo::ScopeChannelConfig* ScopeConfig::add_channels() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.ScopeConfig.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelConfig >&
ScopeConfig::channels() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.ScopeConfig.channels)
  return channels_;
}

// -------------------------------------------------------------------

// ScopeData

// uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ScopeData::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 ScopeData::timestamp() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeData.timestamp)
  return timestamp_;
}
inline void ScopeData::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeData.timestamp)
}

// bytes data = 2;
inline void ScopeData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScopeData::data() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeData.data)
  return data_.GetNoArena();
}
inline void ScopeData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeData.data)
}
#if LANG_CXX11
inline void ScopeData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.nucleo.ScopeData.data)
}
#endif
inline void ScopeData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.nucleo.ScopeData.data)
}
inline void ScopeData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.nucleo.ScopeData.data)
}
inline ::std::string* ScopeData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.ScopeData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScopeData::release_data() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.ScopeData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScopeData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.ScopeData.data)
}

// -------------------------------------------------------------------

// ScopeChannelValues

// repeated float float_values = 1;
inline int ScopeChannelValues::float_values_size() const {
  return float_values_.size();
}
inline void ScopeChannelValues::clear_float_values() {
  float_values_.Clear();
}
inline float ScopeChannelValues::float_values(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeChannelValues.float_values)
  return float_values_.Get(index);
}
inline void ScopeChannelValues::set_float_values(int index, float value) {
  float_values_.Set(index, value);
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeChannelValues.float_values)
}
inline void ScopeChannelValues::add_float_values(float value) {
  float_values_.Add(value);
  // @@protoc_insertion_point(field_add:goldo.nucleo.ScopeChannelValues.float_values)
}
inline const ::google::protobuf::RepeatedField< float >&
ScopeChannelValues::float_values() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.ScopeChannelValues.float_values)
  return float_values_;
}
inline ::google::protobuf::RepeatedField< float >*
ScopeChannelValues::mutable_float_values() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.ScopeChannelValues.float_values)
  return &float_values_;
}

// -------------------------------------------------------------------

// ScopeValues

// repeated float timestamps = 1;
inline int ScopeValues::timestamps_size() const {
  return timestamps_.size();
}
inline void ScopeValues::clear_timestamps() {
  timestamps_.Clear();
}
inline float ScopeValues::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeValues.timestamps)
  return timestamps_.Get(index);
}
inline void ScopeValues::set_timestamps(int index, float value) {
  timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:goldo.nucleo.ScopeValues.timestamps)
}
inline void ScopeValues::add_timestamps(float value) {
  timestamps_.Add(value);
  // @@protoc_insertion_point(field_add:goldo.nucleo.ScopeValues.timestamps)
}
inline const ::google::protobuf::RepeatedField< float >&
ScopeValues::timestamps() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.ScopeValues.timestamps)
  return timestamps_;
}
inline ::google::protobuf::RepeatedField< float >*
ScopeValues::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.ScopeValues.timestamps)
  return &timestamps_;
}

// repeated .goldo.nucleo.ScopeChannelValues channels = 2;
inline int ScopeValues::channels_size() const {
  return channels_.size();
}
inline void ScopeValues::clear_channels() {
  channels_.Clear();
}
inline ::goldo::nucleo::ScopeChannelValues* ScopeValues::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.ScopeValues.channels)
  return channels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelValues >*
ScopeValues::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.ScopeValues.channels)
  return &channels_;
}
inline const ::goldo::nucleo::ScopeChannelValues& ScopeValues::channels(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.ScopeValues.channels)
  return channels_.Get(index);
}
inline ::goldo::nucleo::ScopeChannelValues* ScopeValues::add_channels() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.ScopeValues.channels)
  return channels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::ScopeChannelValues >&
ScopeValues::channels() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.ScopeValues.channels)
  return channels_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nucleo
}  // namespace goldo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::goldo::nucleo::ScopeChannelConfig_Encoding> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::nucleo::ScopeChannelConfig_Encoding>() {
  return ::goldo::nucleo::ScopeChannelConfig_Encoding_descriptor();
}
template <> struct is_proto_enum< ::goldo::nucleo::SensorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::nucleo::SensorType>() {
  return ::goldo::nucleo::SensorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2fnucleo_2eproto
