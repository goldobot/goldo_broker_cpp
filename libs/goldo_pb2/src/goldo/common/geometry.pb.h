// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/common/geometry.proto

#ifndef PROTOBUF_INCLUDED_goldo_2fcommon_2fgeometry_2eproto
#define PROTOBUF_INCLUDED_goldo_2fcommon_2fgeometry_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2fcommon_2fgeometry_2eproto 

namespace protobuf_goldo_2fcommon_2fgeometry_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2fcommon_2fgeometry_2eproto
namespace goldo {
namespace common {
namespace geometry {
class Box;
class BoxDefaultTypeInternal;
extern BoxDefaultTypeInternal _Box_default_instance_;
class Circle;
class CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class StaticPose;
class StaticPoseDefaultTypeInternal;
extern StaticPoseDefaultTypeInternal _StaticPose_default_instance_;
}  // namespace geometry
}  // namespace common
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::common::geometry::Box* Arena::CreateMaybeMessage<::goldo::common::geometry::Box>(Arena*);
template<> ::goldo::common::geometry::Circle* Arena::CreateMaybeMessage<::goldo::common::geometry::Circle>(Arena*);
template<> ::goldo::common::geometry::Point* Arena::CreateMaybeMessage<::goldo::common::geometry::Point>(Arena*);
template<> ::goldo::common::geometry::PointCloud* Arena::CreateMaybeMessage<::goldo::common::geometry::PointCloud>(Arena*);
template<> ::goldo::common::geometry::Polygon* Arena::CreateMaybeMessage<::goldo::common::geometry::Polygon>(Arena*);
template<> ::goldo::common::geometry::Pose* Arena::CreateMaybeMessage<::goldo::common::geometry::Pose>(Arena*);
template<> ::goldo::common::geometry::StaticPose* Arena::CreateMaybeMessage<::goldo::common::geometry::StaticPose>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace common {
namespace geometry {

// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PointCloud* other);
  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return CreateMaybeMessage<PointCloud>(NULL);
  }

  PointCloud* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 num_points = 1;
  void clear_num_points();
  static const int kNumPointsFieldNumber = 1;
  ::google::protobuf::uint32 num_points() const;
  void set_num_points(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.PointCloud)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 num_points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaticPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.StaticPose) */ {
 public:
  StaticPose();
  virtual ~StaticPose();

  StaticPose(const StaticPose& from);

  inline StaticPose& operator=(const StaticPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaticPose(StaticPose&& from) noexcept
    : StaticPose() {
    *this = ::std::move(from);
  }

  inline StaticPose& operator=(StaticPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticPose* internal_default_instance() {
    return reinterpret_cast<const StaticPose*>(
               &_StaticPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(StaticPose* other);
  friend void swap(StaticPose& a, StaticPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaticPose* New() const final {
    return CreateMaybeMessage<StaticPose>(NULL);
  }

  StaticPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StaticPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StaticPose& from);
  void MergeFrom(const StaticPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Point& _internal_position() const;
  public:
  const ::goldo::common::geometry::Point& position() const;
  ::goldo::common::geometry::Point* release_position();
  ::goldo::common::geometry::Point* mutable_position();
  void set_allocated_position(::goldo::common::geometry::Point* position);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.StaticPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* position_;
  float yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Point& _internal_position() const;
  public:
  const ::goldo::common::geometry::Point& position() const;
  ::goldo::common::geometry::Point* release_position();
  ::goldo::common::geometry::Point* mutable_position();
  void set_allocated_position(::goldo::common::geometry::Point* position);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // float yaw_rate = 4;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 4;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // float acceleration = 5;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 5;
  float acceleration() const;
  void set_acceleration(float value);

  // float angular_acceleration = 6;
  void clear_angular_acceleration();
  static const int kAngularAccelerationFieldNumber = 6;
  float angular_acceleration() const;
  void set_angular_acceleration(float value);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.Pose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* position_;
  float yaw_;
  float speed_;
  float yaw_rate_;
  float acceleration_;
  float angular_acceleration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Circle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.Circle) */ {
 public:
  Circle();
  virtual ~Circle();

  Circle(const Circle& from);

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(Circle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Circle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Circle* other);
  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Circle* New() const final {
    return CreateMaybeMessage<Circle>(NULL);
  }

  Circle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Circle& from);
  void MergeFrom(const Circle& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point center = 1;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Point& _internal_center() const;
  public:
  const ::goldo::common::geometry::Point& center() const;
  ::goldo::common::geometry::Point* release_center();
  ::goldo::common::geometry::Point* mutable_center();
  void set_allocated_center(::goldo::common::geometry::Point* center);

  // float radius = 2;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.Circle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* center_;
  float radius_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Box : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.Box) */ {
 public:
  Box();
  virtual ~Box();

  Box(const Box& from);

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Box(Box&& from) noexcept
    : Box() {
    *this = ::std::move(from);
  }

  inline Box& operator=(Box&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Box& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Box* internal_default_instance() {
    return reinterpret_cast<const Box*>(
               &_Box_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Box* other);
  friend void swap(Box& a, Box& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Box* New() const final {
    return CreateMaybeMessage<Box>(NULL);
  }

  Box* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Box>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Box& from);
  void MergeFrom(const Box& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point pmin = 1;
  bool has_pmin() const;
  void clear_pmin();
  static const int kPminFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Point& _internal_pmin() const;
  public:
  const ::goldo::common::geometry::Point& pmin() const;
  ::goldo::common::geometry::Point* release_pmin();
  ::goldo::common::geometry::Point* mutable_pmin();
  void set_allocated_pmin(::goldo::common::geometry::Point* pmin);

  // .goldo.common.geometry.Point pmax = 2;
  bool has_pmax() const;
  void clear_pmax();
  static const int kPmaxFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Point& _internal_pmax() const;
  public:
  const ::goldo::common::geometry::Point& pmax() const;
  ::goldo::common::geometry::Point* release_pmax();
  ::goldo::common::geometry::Point* mutable_pmax();
  void set_allocated_pmax(::goldo::common::geometry::Point* pmax);

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.Box)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* pmin_;
  ::goldo::common::geometry::Point* pmax_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.common.geometry.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const final {
    return CreateMaybeMessage<Polygon>(NULL);
  }

  Polygon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.common.geometry.Point vertices = 1;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 1;
  ::goldo::common::geometry::Point* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
      mutable_vertices();
  const ::goldo::common::geometry::Point& vertices(int index) const;
  ::goldo::common::geometry::Point* add_vertices();
  const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
      vertices() const;

  // @@protoc_insertion_point(class_scope:goldo.common.geometry.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point > vertices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fcommon_2fgeometry_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// float x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Point.x)
}

// float y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Point.y)
}

// -------------------------------------------------------------------

// PointCloud

// uint32 num_points = 1;
inline void PointCloud::clear_num_points() {
  num_points_ = 0u;
}
inline ::google::protobuf::uint32 PointCloud::num_points() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.PointCloud.num_points)
  return num_points_;
}
inline void PointCloud::set_num_points(::google::protobuf::uint32 value) {
  
  num_points_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.PointCloud.num_points)
}

// bytes data = 2;
inline void PointCloud::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PointCloud::data() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.PointCloud.data)
  return data_.GetNoArena();
}
inline void PointCloud::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.common.geometry.PointCloud.data)
}
#if LANG_CXX11
inline void PointCloud::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.common.geometry.PointCloud.data)
}
#endif
inline void PointCloud::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.common.geometry.PointCloud.data)
}
inline void PointCloud::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.common.geometry.PointCloud.data)
}
inline ::std::string* PointCloud::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.PointCloud.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PointCloud::release_data() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.PointCloud.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PointCloud::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.PointCloud.data)
}

// -------------------------------------------------------------------

// StaticPose

// .goldo.common.geometry.Point position = 1;
inline bool StaticPose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void StaticPose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::goldo::common::geometry::Point& StaticPose::_internal_position() const {
  return *position_;
}
inline const ::goldo::common::geometry::Point& StaticPose::position() const {
  const ::goldo::common::geometry::Point* p = position_;
  // @@protoc_insertion_point(field_get:goldo.common.geometry.StaticPose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* StaticPose::release_position() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.StaticPose.position)
  
  ::goldo::common::geometry::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* StaticPose::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.StaticPose.position)
  return position_;
}
inline void StaticPose::set_allocated_position(::goldo::common::geometry::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.StaticPose.position)
}

// float yaw = 2;
inline void StaticPose::clear_yaw() {
  yaw_ = 0;
}
inline float StaticPose::yaw() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.StaticPose.yaw)
  return yaw_;
}
inline void StaticPose::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.StaticPose.yaw)
}

// -------------------------------------------------------------------

// Pose

// .goldo.common.geometry.Point position = 1;
inline bool Pose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void Pose::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::goldo::common::geometry::Point& Pose::_internal_position() const {
  return *position_;
}
inline const ::goldo::common::geometry::Point& Pose::position() const {
  const ::goldo::common::geometry::Point* p = position_;
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.Pose.position)
  
  ::goldo::common::geometry::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* Pose::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.Pose.position)
  return position_;
}
inline void Pose::set_allocated_position(::goldo::common::geometry::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.Pose.position)
}

// float yaw = 2;
inline void Pose::clear_yaw() {
  yaw_ = 0;
}
inline float Pose::yaw() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.yaw)
  return yaw_;
}
inline void Pose::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Pose.yaw)
}

// float speed = 3;
inline void Pose::clear_speed() {
  speed_ = 0;
}
inline float Pose::speed() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.speed)
  return speed_;
}
inline void Pose::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Pose.speed)
}

// float yaw_rate = 4;
inline void Pose::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float Pose::yaw_rate() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.yaw_rate)
  return yaw_rate_;
}
inline void Pose::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Pose.yaw_rate)
}

// float acceleration = 5;
inline void Pose::clear_acceleration() {
  acceleration_ = 0;
}
inline float Pose::acceleration() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.acceleration)
  return acceleration_;
}
inline void Pose::set_acceleration(float value) {
  
  acceleration_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Pose.acceleration)
}

// float angular_acceleration = 6;
inline void Pose::clear_angular_acceleration() {
  angular_acceleration_ = 0;
}
inline float Pose::angular_acceleration() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Pose.angular_acceleration)
  return angular_acceleration_;
}
inline void Pose::set_angular_acceleration(float value) {
  
  angular_acceleration_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Pose.angular_acceleration)
}

// -------------------------------------------------------------------

// Circle

// .goldo.common.geometry.Point center = 1;
inline bool Circle::has_center() const {
  return this != internal_default_instance() && center_ != NULL;
}
inline void Circle::clear_center() {
  if (GetArenaNoVirtual() == NULL && center_ != NULL) {
    delete center_;
  }
  center_ = NULL;
}
inline const ::goldo::common::geometry::Point& Circle::_internal_center() const {
  return *center_;
}
inline const ::goldo::common::geometry::Point& Circle::center() const {
  const ::goldo::common::geometry::Point* p = center_;
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Circle.center)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* Circle::release_center() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.Circle.center)
  
  ::goldo::common::geometry::Point* temp = center_;
  center_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* Circle::mutable_center() {
  
  if (center_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.Circle.center)
  return center_;
}
inline void Circle::set_allocated_center(::goldo::common::geometry::Point* center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_;
  }
  if (center) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.Circle.center)
}

// float radius = 2;
inline void Circle::clear_radius() {
  radius_ = 0;
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Circle.radius)
  return radius_;
}
inline void Circle::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:goldo.common.geometry.Circle.radius)
}

// -------------------------------------------------------------------

// Box

// .goldo.common.geometry.Point pmin = 1;
inline bool Box::has_pmin() const {
  return this != internal_default_instance() && pmin_ != NULL;
}
inline void Box::clear_pmin() {
  if (GetArenaNoVirtual() == NULL && pmin_ != NULL) {
    delete pmin_;
  }
  pmin_ = NULL;
}
inline const ::goldo::common::geometry::Point& Box::_internal_pmin() const {
  return *pmin_;
}
inline const ::goldo::common::geometry::Point& Box::pmin() const {
  const ::goldo::common::geometry::Point* p = pmin_;
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Box.pmin)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* Box::release_pmin() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.Box.pmin)
  
  ::goldo::common::geometry::Point* temp = pmin_;
  pmin_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* Box::mutable_pmin() {
  
  if (pmin_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    pmin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.Box.pmin)
  return pmin_;
}
inline void Box::set_allocated_pmin(::goldo::common::geometry::Point* pmin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pmin_;
  }
  if (pmin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pmin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pmin, submessage_arena);
    }
    
  } else {
    
  }
  pmin_ = pmin;
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.Box.pmin)
}

// .goldo.common.geometry.Point pmax = 2;
inline bool Box::has_pmax() const {
  return this != internal_default_instance() && pmax_ != NULL;
}
inline void Box::clear_pmax() {
  if (GetArenaNoVirtual() == NULL && pmax_ != NULL) {
    delete pmax_;
  }
  pmax_ = NULL;
}
inline const ::goldo::common::geometry::Point& Box::_internal_pmax() const {
  return *pmax_;
}
inline const ::goldo::common::geometry::Point& Box::pmax() const {
  const ::goldo::common::geometry::Point* p = pmax_;
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Box.pmax)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* Box::release_pmax() {
  // @@protoc_insertion_point(field_release:goldo.common.geometry.Box.pmax)
  
  ::goldo::common::geometry::Point* temp = pmax_;
  pmax_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* Box::mutable_pmax() {
  
  if (pmax_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    pmax_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.Box.pmax)
  return pmax_;
}
inline void Box::set_allocated_pmax(::goldo::common::geometry::Point* pmax) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pmax_;
  }
  if (pmax) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pmax = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pmax, submessage_arena);
    }
    
  } else {
    
  }
  pmax_ = pmax;
  // @@protoc_insertion_point(field_set_allocated:goldo.common.geometry.Box.pmax)
}

// -------------------------------------------------------------------

// Polygon

// repeated .goldo.common.geometry.Point vertices = 1;
inline int Polygon::vertices_size() const {
  return vertices_.size();
}
inline void Polygon::clear_vertices() {
  vertices_.Clear();
}
inline ::goldo::common::geometry::Point* Polygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.common.geometry.Polygon.vertices)
  return vertices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
Polygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:goldo.common.geometry.Polygon.vertices)
  return &vertices_;
}
inline const ::goldo::common::geometry::Point& Polygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:goldo.common.geometry.Polygon.vertices)
  return vertices_.Get(index);
}
inline ::goldo::common::geometry::Point* Polygon::add_vertices() {
  // @@protoc_insertion_point(field_add:goldo.common.geometry.Polygon.vertices)
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
Polygon::vertices() const {
  // @@protoc_insertion_point(field_list:goldo.common.geometry.Polygon.vertices)
  return vertices_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace geometry
}  // namespace common
}  // namespace goldo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2fcommon_2fgeometry_2eproto
