// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/robot.proto

#ifndef PROTOBUF_INCLUDED_goldo_2frobot_2eproto
#define PROTOBUF_INCLUDED_goldo_2frobot_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "goldo/nucleo.pb.h"
#include "goldo/rplidar.pb.h"
#include "goldo/table.pb.h"
#include "goldo/strategy.pb.h"
#include "goldo/common/geometry.pb.h"
#include "goldo/nucleo/servos.pb.h"
#include "goldo/pb2_options.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2frobot_2eproto 

namespace protobuf_goldo_2frobot_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2frobot_2eproto
namespace goldo {
namespace robot {
class RPLidarState;
class RPLidarStateDefaultTypeInternal;
extern RPLidarStateDefaultTypeInternal _RPLidarState_default_instance_;
class RobotConfig;
class RobotConfigDefaultTypeInternal;
extern RobotConfigDefaultTypeInternal _RobotConfig_default_instance_;
class RobotGeometry;
class RobotGeometryDefaultTypeInternal;
extern RobotGeometryDefaultTypeInternal _RobotGeometry_default_instance_;
class RobotState;
class RobotStateDefaultTypeInternal;
extern RobotStateDefaultTypeInternal _RobotState_default_instance_;
class RobotState_SensorsEntry_DoNotUse;
class RobotState_SensorsEntry_DoNotUseDefaultTypeInternal;
extern RobotState_SensorsEntry_DoNotUseDefaultTypeInternal _RobotState_SensorsEntry_DoNotUse_default_instance_;
class RobotState_ServosEntry_DoNotUse;
class RobotState_ServosEntry_DoNotUseDefaultTypeInternal;
extern RobotState_ServosEntry_DoNotUseDefaultTypeInternal _RobotState_ServosEntry_DoNotUse_default_instance_;
class SequencesFile;
class SequencesFileDefaultTypeInternal;
extern SequencesFileDefaultTypeInternal _SequencesFile_default_instance_;
class SequencesOption;
class SequencesOptionDefaultTypeInternal;
extern SequencesOptionDefaultTypeInternal _SequencesOption_default_instance_;
}  // namespace robot
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::robot::RPLidarState* Arena::CreateMaybeMessage<::goldo::robot::RPLidarState>(Arena*);
template<> ::goldo::robot::RobotConfig* Arena::CreateMaybeMessage<::goldo::robot::RobotConfig>(Arena*);
template<> ::goldo::robot::RobotGeometry* Arena::CreateMaybeMessage<::goldo::robot::RobotGeometry>(Arena*);
template<> ::goldo::robot::RobotState* Arena::CreateMaybeMessage<::goldo::robot::RobotState>(Arena*);
template<> ::goldo::robot::RobotState_SensorsEntry_DoNotUse* Arena::CreateMaybeMessage<::goldo::robot::RobotState_SensorsEntry_DoNotUse>(Arena*);
template<> ::goldo::robot::RobotState_ServosEntry_DoNotUse* Arena::CreateMaybeMessage<::goldo::robot::RobotState_ServosEntry_DoNotUse>(Arena*);
template<> ::goldo::robot::SequencesFile* Arena::CreateMaybeMessage<::goldo::robot::SequencesFile>(Arena*);
template<> ::goldo::robot::SequencesOption* Arena::CreateMaybeMessage<::goldo::robot::SequencesOption>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace robot {

enum Side {
  SIDE_UNKNOWN = 0,
  SIDE_BLUE = 1,
  SIDE_YELLOW = 2,
  Side_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Side_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Side_IsValid(int value);
const Side Side_MIN = SIDE_UNKNOWN;
const Side Side_MAX = SIDE_YELLOW;
const int Side_ARRAYSIZE = Side_MAX + 1;

const ::google::protobuf::EnumDescriptor* Side_descriptor();
inline const ::std::string& Side_Name(Side value) {
  return ::google::protobuf::internal::NameOfEnum(
    Side_descriptor(), value);
}
inline bool Side_Parse(
    const ::std::string& name, Side* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Side>(
    Side_descriptor(), name, value);
}
enum MatchState {
  MATCH_IDLE = 0,
  MATCH_PREMATCH = 1,
  MATCH_WAIT_FOR_START_OF_MATCH = 2,
  MATCH_MATCH = 3,
  MATCH_MATCH_FINISHED = 4,
  MatchState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MatchState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MatchState_IsValid(int value);
const MatchState MatchState_MIN = MATCH_IDLE;
const MatchState MatchState_MAX = MATCH_MATCH_FINISHED;
const int MatchState_ARRAYSIZE = MatchState_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchState_descriptor();
inline const ::std::string& MatchState_Name(MatchState value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchState_descriptor(), value);
}
inline bool MatchState_Parse(
    const ::std::string& name, MatchState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchState>(
    MatchState_descriptor(), name, value);
}
// ===================================================================

class RobotGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.RobotGeometry) */ {
 public:
  RobotGeometry();
  virtual ~RobotGeometry();

  RobotGeometry(const RobotGeometry& from);

  inline RobotGeometry& operator=(const RobotGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotGeometry(RobotGeometry&& from) noexcept
    : RobotGeometry() {
    *this = ::std::move(from);
  }

  inline RobotGeometry& operator=(RobotGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotGeometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotGeometry* internal_default_instance() {
    return reinterpret_cast<const RobotGeometry*>(
               &_RobotGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RobotGeometry* other);
  friend void swap(RobotGeometry& a, RobotGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotGeometry* New() const final {
    return CreateMaybeMessage<RobotGeometry>(NULL);
  }

  RobotGeometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotGeometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotGeometry& from);
  void MergeFrom(const RobotGeometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.common.geometry.Point outline = 3 [(.goldo.pb2_options.cpp_type) = VOID];
  int outline_size() const;
  void clear_outline();
  static const int kOutlineFieldNumber = 3;
  ::goldo::common::geometry::Point* mutable_outline(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
      mutable_outline();
  const ::goldo::common::geometry::Point& outline(int index) const;
  ::goldo::common::geometry::Point* add_outline();
  const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
      outline() const;

  // float front_length = 1;
  void clear_front_length();
  static const int kFrontLengthFieldNumber = 1;
  float front_length() const;
  void set_front_length(float value);

  // float back_length = 2;
  void clear_back_length();
  static const int kBackLengthFieldNumber = 2;
  float back_length() const;
  void set_back_length(float value);

  // @@protoc_insertion_point(class_scope:goldo.robot.RobotGeometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point > outline_;
  float front_length_;
  float back_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SequencesFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.SequencesFile) */ {
 public:
  SequencesFile();
  virtual ~SequencesFile();

  SequencesFile(const SequencesFile& from);

  inline SequencesFile& operator=(const SequencesFile& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequencesFile(SequencesFile&& from) noexcept
    : SequencesFile() {
    *this = ::std::move(from);
  }

  inline SequencesFile& operator=(SequencesFile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequencesFile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequencesFile* internal_default_instance() {
    return reinterpret_cast<const SequencesFile*>(
               &_SequencesFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SequencesFile* other);
  friend void swap(SequencesFile& a, SequencesFile& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequencesFile* New() const final {
    return CreateMaybeMessage<SequencesFile>(NULL);
  }

  SequencesFile* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SequencesFile>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SequencesFile& from);
  void MergeFrom(const SequencesFile& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequencesFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string path = 1;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string body = 2;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  #if LANG_CXX11
  void set_body(::std::string&& value);
  #endif
  void set_body(const char* value);
  void set_body(const char* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:goldo.robot.SequencesFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SequencesOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.SequencesOption) */ {
 public:
  SequencesOption();
  virtual ~SequencesOption();

  SequencesOption(const SequencesOption& from);

  inline SequencesOption& operator=(const SequencesOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SequencesOption(SequencesOption&& from) noexcept
    : SequencesOption() {
    *this = ::std::move(from);
  }

  inline SequencesOption& operator=(SequencesOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SequencesOption& default_instance();

  enum DefaultValueCase {
    kDefaultBool = 2,
    DEFAULT_VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SequencesOption* internal_default_instance() {
    return reinterpret_cast<const SequencesOption*>(
               &_SequencesOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(SequencesOption* other);
  friend void swap(SequencesOption& a, SequencesOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SequencesOption* New() const final {
    return CreateMaybeMessage<SequencesOption>(NULL);
  }

  SequencesOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SequencesOption>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SequencesOption& from);
  void MergeFrom(const SequencesOption& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SequencesOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bool default_bool = 2;
  private:
  bool has_default_bool() const;
  public:
  void clear_default_bool();
  static const int kDefaultBoolFieldNumber = 2;
  bool default_bool() const;
  void set_default_bool(bool value);

  void clear_default_value();
  DefaultValueCase default_value_case() const;
  // @@protoc_insertion_point(class_scope:goldo.robot.SequencesOption)
 private:
  void set_has_default_bool();

  inline bool has_default_value() const;
  inline void clear_has_default_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union DefaultValueUnion {
    DefaultValueUnion() {}
    bool default_bool_;
  } default_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.RobotConfig) */ {
 public:
  RobotConfig();
  virtual ~RobotConfig();

  RobotConfig(const RobotConfig& from);

  inline RobotConfig& operator=(const RobotConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotConfig(RobotConfig&& from) noexcept
    : RobotConfig() {
    *this = ::std::move(from);
  }

  inline RobotConfig& operator=(RobotConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotConfig* internal_default_instance() {
    return reinterpret_cast<const RobotConfig*>(
               &_RobotConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RobotConfig* other);
  friend void swap(RobotConfig& a, RobotConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotConfig* New() const final {
    return CreateMaybeMessage<RobotConfig>(NULL);
  }

  RobotConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotConfig& from);
  void MergeFrom(const RobotConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sequences_names = 40;
  int sequences_names_size() const;
  void clear_sequences_names();
  static const int kSequencesNamesFieldNumber = 40;
  const ::std::string& sequences_names(int index) const;
  ::std::string* mutable_sequences_names(int index);
  void set_sequences_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sequences_names(int index, ::std::string&& value);
  #endif
  void set_sequences_names(int index, const char* value);
  void set_sequences_names(int index, const char* value, size_t size);
  ::std::string* add_sequences_names();
  void add_sequences_names(const ::std::string& value);
  #if LANG_CXX11
  void add_sequences_names(::std::string&& value);
  #endif
  void add_sequences_names(const char* value);
  void add_sequences_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sequences_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sequences_names();

  // repeated .goldo.robot.SequencesFile sequences_files = 41;
  int sequences_files_size() const;
  void clear_sequences_files();
  static const int kSequencesFilesFieldNumber = 41;
  ::goldo::robot::SequencesFile* mutable_sequences_files(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesFile >*
      mutable_sequences_files();
  const ::goldo::robot::SequencesFile& sequences_files(int index) const;
  ::goldo::robot::SequencesFile* add_sequences_files();
  const ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesFile >&
      sequences_files() const;

  // repeated .goldo.robot.SequencesOption sequences_options = 42;
  int sequences_options_size() const;
  void clear_sequences_options();
  static const int kSequencesOptionsFieldNumber = 42;
  ::goldo::robot::SequencesOption* mutable_sequences_options(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesOption >*
      mutable_sequences_options();
  const ::goldo::robot::SequencesOption& sequences_options(int index) const;
  ::goldo::robot::SequencesOption* add_sequences_options();
  const ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesOption >&
      sequences_options() const;

  // .goldo.nucleo.NucleoConfig nucleo = 1;
  bool has_nucleo() const;
  void clear_nucleo();
  static const int kNucleoFieldNumber = 1;
  private:
  const ::goldo::nucleo::NucleoConfig& _internal_nucleo() const;
  public:
  const ::goldo::nucleo::NucleoConfig& nucleo() const;
  ::goldo::nucleo::NucleoConfig* release_nucleo();
  ::goldo::nucleo::NucleoConfig* mutable_nucleo();
  void set_allocated_nucleo(::goldo::nucleo::NucleoConfig* nucleo);

  // .goldo.robot.RobotGeometry robot_geometry = 2;
  bool has_robot_geometry() const;
  void clear_robot_geometry();
  static const int kRobotGeometryFieldNumber = 2;
  private:
  const ::goldo::robot::RobotGeometry& _internal_robot_geometry() const;
  public:
  const ::goldo::robot::RobotGeometry& robot_geometry() const;
  ::goldo::robot::RobotGeometry* release_robot_geometry();
  ::goldo::robot::RobotGeometry* mutable_robot_geometry();
  void set_allocated_robot_geometry(::goldo::robot::RobotGeometry* robot_geometry);

  // .goldo.rplidar.RPLidarConfig rplidar = 50;
  bool has_rplidar() const;
  void clear_rplidar();
  static const int kRplidarFieldNumber = 50;
  private:
  const ::goldo::rplidar::RPLidarConfig& _internal_rplidar() const;
  public:
  const ::goldo::rplidar::RPLidarConfig& rplidar() const;
  ::goldo::rplidar::RPLidarConfig* release_rplidar();
  ::goldo::rplidar::RPLidarConfig* mutable_rplidar();
  void set_allocated_rplidar(::goldo::rplidar::RPLidarConfig* rplidar);

  // .goldo.strategy.StrategyConfig strategy = 60;
  bool has_strategy() const;
  void clear_strategy();
  static const int kStrategyFieldNumber = 60;
  private:
  const ::goldo::strategy::StrategyConfig& _internal_strategy() const;
  public:
  const ::goldo::strategy::StrategyConfig& strategy() const;
  ::goldo::strategy::StrategyConfig* release_strategy();
  ::goldo::strategy::StrategyConfig* mutable_strategy();
  void set_allocated_strategy(::goldo::strategy::StrategyConfig* strategy);

  // @@protoc_insertion_point(class_scope:goldo.robot.RobotConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sequences_names_;
  ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesFile > sequences_files_;
  ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesOption > sequences_options_;
  ::goldo::nucleo::NucleoConfig* nucleo_;
  ::goldo::robot::RobotGeometry* robot_geometry_;
  ::goldo::rplidar::RPLidarConfig* rplidar_;
  ::goldo::strategy::StrategyConfig* strategy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RPLidarState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.RPLidarState) */ {
 public:
  RPLidarState();
  virtual ~RPLidarState();

  RPLidarState(const RPLidarState& from);

  inline RPLidarState& operator=(const RPLidarState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RPLidarState(RPLidarState&& from) noexcept
    : RPLidarState() {
    *this = ::std::move(from);
  }

  inline RPLidarState& operator=(RPLidarState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPLidarState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RPLidarState* internal_default_instance() {
    return reinterpret_cast<const RPLidarState*>(
               &_RPLidarState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RPLidarState* other);
  friend void swap(RPLidarState& a, RPLidarState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RPLidarState* New() const final {
    return CreateMaybeMessage<RPLidarState>(NULL);
  }

  RPLidarState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RPLidarState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RPLidarState& from);
  void MergeFrom(const RPLidarState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RPLidarState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.rplidar.RobotDetection detections = 10;
  int detections_size() const;
  void clear_detections();
  static const int kDetectionsFieldNumber = 10;
  ::goldo::rplidar::RobotDetection* mutable_detections(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >*
      mutable_detections();
  const ::goldo::rplidar::RobotDetection& detections(int index) const;
  ::goldo::rplidar::RobotDetection* add_detections();
  const ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >&
      detections() const;

  // .goldo.rplidar.Zones zones = 11;
  bool has_zones() const;
  void clear_zones();
  static const int kZonesFieldNumber = 11;
  private:
  const ::goldo::rplidar::Zones& _internal_zones() const;
  public:
  const ::goldo::rplidar::Zones& zones() const;
  ::goldo::rplidar::Zones* release_zones();
  ::goldo::rplidar::Zones* mutable_zones();
  void set_allocated_zones(::goldo::rplidar::Zones* zones);

  // bool running = 1;
  void clear_running();
  static const int kRunningFieldNumber = 1;
  bool running() const;
  void set_running(bool value);

  // @@protoc_insertion_point(class_scope:goldo.robot.RPLidarState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection > detections_;
  ::goldo::rplidar::Zones* zones_;
  bool running_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RobotState_SensorsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<RobotState_SensorsEntry_DoNotUse, 
    ::std::string, bool,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<RobotState_SensorsEntry_DoNotUse, 
    ::std::string, bool,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
    0 > SuperType;
  RobotState_SensorsEntry_DoNotUse();
  RobotState_SensorsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RobotState_SensorsEntry_DoNotUse& other);
  static const RobotState_SensorsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RobotState_SensorsEntry_DoNotUse*>(&_RobotState_SensorsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class RobotState_ServosEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<RobotState_ServosEntry_DoNotUse, 
    ::std::string, ::goldo::nucleo::servos::ServoState,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<RobotState_ServosEntry_DoNotUse, 
    ::std::string, ::goldo::nucleo::servos::ServoState,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  RobotState_ServosEntry_DoNotUse();
  RobotState_ServosEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const RobotState_ServosEntry_DoNotUse& other);
  static const RobotState_ServosEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RobotState_ServosEntry_DoNotUse*>(&_RobotState_ServosEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class RobotState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.robot.RobotState) */ {
 public:
  RobotState();
  virtual ~RobotState();

  RobotState(const RobotState& from);

  inline RobotState& operator=(const RobotState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RobotState(RobotState&& from) noexcept
    : RobotState() {
    *this = ::std::move(from);
  }

  inline RobotState& operator=(RobotState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotState* internal_default_instance() {
    return reinterpret_cast<const RobotState*>(
               &_RobotState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RobotState* other);
  friend void swap(RobotState& a, RobotState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RobotState* New() const final {
    return CreateMaybeMessage<RobotState>(NULL);
  }

  RobotState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RobotState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RobotState& from);
  void MergeFrom(const RobotState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bool> sensors = 2;
  int sensors_size() const;
  void clear_sensors();
  static const int kSensorsFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, bool >&
      sensors() const;
  ::google::protobuf::Map< ::std::string, bool >*
      mutable_sensors();

  // repeated .goldo.rplidar.RobotDetection rplidar_detections = 10;
  int rplidar_detections_size() const;
  void clear_rplidar_detections();
  static const int kRplidarDetectionsFieldNumber = 10;
  ::goldo::rplidar::RobotDetection* mutable_rplidar_detections(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >*
      mutable_rplidar_detections();
  const ::goldo::rplidar::RobotDetection& rplidar_detections(int index) const;
  ::goldo::rplidar::RobotDetection* add_rplidar_detections();
  const ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >&
      rplidar_detections() const;

  // map<string, .goldo.nucleo.servos.ServoState> servos = 13;
  int servos_size() const;
  void clear_servos();
  static const int kServosFieldNumber = 13;
  const ::google::protobuf::Map< ::std::string, ::goldo::nucleo::servos::ServoState >&
      servos() const;
  ::google::protobuf::Map< ::std::string, ::goldo::nucleo::servos::ServoState >*
      mutable_servos();

  // .goldo.nucleo.NucleoState nucleo = 1;
  bool has_nucleo() const;
  void clear_nucleo();
  static const int kNucleoFieldNumber = 1;
  private:
  const ::goldo::nucleo::NucleoState& _internal_nucleo() const;
  public:
  const ::goldo::nucleo::NucleoState& nucleo() const;
  ::goldo::nucleo::NucleoState* release_nucleo();
  ::goldo::nucleo::NucleoState* mutable_nucleo();
  void set_allocated_nucleo(::goldo::nucleo::NucleoState* nucleo);

  // .goldo.table.TableState table = 3;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 3;
  private:
  const ::goldo::table::TableState& _internal_table() const;
  public:
  const ::goldo::table::TableState& table() const;
  ::goldo::table::TableState* release_table();
  ::goldo::table::TableState* mutable_table();
  void set_allocated_table(::goldo::table::TableState* table);

  // .goldo.common.geometry.Pose robot_pose = 8;
  bool has_robot_pose() const;
  void clear_robot_pose();
  static const int kRobotPoseFieldNumber = 8;
  private:
  const ::goldo::common::geometry::Pose& _internal_robot_pose() const;
  public:
  const ::goldo::common::geometry::Pose& robot_pose() const;
  ::goldo::common::geometry::Pose* release_robot_pose();
  ::goldo::common::geometry::Pose* mutable_robot_pose();
  void set_allocated_robot_pose(::goldo::common::geometry::Pose* robot_pose);

  // .goldo.robot.RPLidarState rplidar = 11;
  bool has_rplidar() const;
  void clear_rplidar();
  static const int kRplidarFieldNumber = 11;
  private:
  const ::goldo::robot::RPLidarState& _internal_rplidar() const;
  public:
  const ::goldo::robot::RPLidarState& rplidar() const;
  ::goldo::robot::RPLidarState* release_rplidar();
  ::goldo::robot::RPLidarState* mutable_rplidar();
  void set_allocated_rplidar(::goldo::robot::RPLidarState* rplidar);

  // uint32 score = 5;
  void clear_score();
  static const int kScoreFieldNumber = 5;
  ::google::protobuf::uint32 score() const;
  void set_score(::google::protobuf::uint32 value);

  // uint32 match_timer = 6;
  void clear_match_timer();
  static const int kMatchTimerFieldNumber = 6;
  ::google::protobuf::uint32 match_timer() const;
  void set_match_timer(::google::protobuf::uint32 value);

  // bool emergency_stop = 4;
  void clear_emergency_stop();
  static const int kEmergencyStopFieldNumber = 4;
  bool emergency_stop() const;
  void set_emergency_stop(bool value);

  // bool tirette = 9;
  void clear_tirette();
  static const int kTiretteFieldNumber = 9;
  bool tirette() const;
  void set_tirette(bool value);

  // .goldo.robot.Side side = 7;
  void clear_side();
  static const int kSideFieldNumber = 7;
  ::goldo::robot::Side side() const;
  void set_side(::goldo::robot::Side value);

  // .goldo.robot.MatchState match_state = 12;
  void clear_match_state();
  static const int kMatchStateFieldNumber = 12;
  ::goldo::robot::MatchState match_state() const;
  void set_match_state(::goldo::robot::MatchState value);

  // @@protoc_insertion_point(class_scope:goldo.robot.RobotState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      RobotState_SensorsEntry_DoNotUse,
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 > sensors_;
  ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection > rplidar_detections_;
  ::google::protobuf::internal::MapField<
      RobotState_ServosEntry_DoNotUse,
      ::std::string, ::goldo::nucleo::servos::ServoState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > servos_;
  ::goldo::nucleo::NucleoState* nucleo_;
  ::goldo::table::TableState* table_;
  ::goldo::common::geometry::Pose* robot_pose_;
  ::goldo::robot::RPLidarState* rplidar_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 match_timer_;
  bool emergency_stop_;
  bool tirette_;
  int side_;
  int match_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2frobot_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotGeometry

// float front_length = 1;
inline void RobotGeometry::clear_front_length() {
  front_length_ = 0;
}
inline float RobotGeometry::front_length() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotGeometry.front_length)
  return front_length_;
}
inline void RobotGeometry::set_front_length(float value) {
  
  front_length_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotGeometry.front_length)
}

// float back_length = 2;
inline void RobotGeometry::clear_back_length() {
  back_length_ = 0;
}
inline float RobotGeometry::back_length() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotGeometry.back_length)
  return back_length_;
}
inline void RobotGeometry::set_back_length(float value) {
  
  back_length_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotGeometry.back_length)
}

// repeated .goldo.common.geometry.Point outline = 3 [(.goldo.pb2_options.cpp_type) = VOID];
inline int RobotGeometry::outline_size() const {
  return outline_.size();
}
inline ::goldo::common::geometry::Point* RobotGeometry::mutable_outline(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotGeometry.outline)
  return outline_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
RobotGeometry::mutable_outline() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RobotGeometry.outline)
  return &outline_;
}
inline const ::goldo::common::geometry::Point& RobotGeometry::outline(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotGeometry.outline)
  return outline_.Get(index);
}
inline ::goldo::common::geometry::Point* RobotGeometry::add_outline() {
  // @@protoc_insertion_point(field_add:goldo.robot.RobotGeometry.outline)
  return outline_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
RobotGeometry::outline() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RobotGeometry.outline)
  return outline_;
}

// -------------------------------------------------------------------

// SequencesFile

// string path = 1;
inline void SequencesFile::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SequencesFile::path() const {
  // @@protoc_insertion_point(field_get:goldo.robot.SequencesFile.path)
  return path_.GetNoArena();
}
inline void SequencesFile::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.robot.SequencesFile.path)
}
#if LANG_CXX11
inline void SequencesFile::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.robot.SequencesFile.path)
}
#endif
inline void SequencesFile::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.robot.SequencesFile.path)
}
inline void SequencesFile::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.robot.SequencesFile.path)
}
inline ::std::string* SequencesFile::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:goldo.robot.SequencesFile.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SequencesFile::release_path() {
  // @@protoc_insertion_point(field_release:goldo.robot.SequencesFile.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SequencesFile::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.SequencesFile.path)
}

// string body = 2;
inline void SequencesFile::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SequencesFile::body() const {
  // @@protoc_insertion_point(field_get:goldo.robot.SequencesFile.body)
  return body_.GetNoArena();
}
inline void SequencesFile::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.robot.SequencesFile.body)
}
#if LANG_CXX11
inline void SequencesFile::set_body(::std::string&& value) {
  
  body_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.robot.SequencesFile.body)
}
#endif
inline void SequencesFile::set_body(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.robot.SequencesFile.body)
}
inline void SequencesFile::set_body(const char* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.robot.SequencesFile.body)
}
inline ::std::string* SequencesFile::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:goldo.robot.SequencesFile.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SequencesFile::release_body() {
  // @@protoc_insertion_point(field_release:goldo.robot.SequencesFile.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SequencesFile::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.SequencesFile.body)
}

// -------------------------------------------------------------------

// SequencesOption

// string name = 1;
inline void SequencesOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SequencesOption::name() const {
  // @@protoc_insertion_point(field_get:goldo.robot.SequencesOption.name)
  return name_.GetNoArena();
}
inline void SequencesOption::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.robot.SequencesOption.name)
}
#if LANG_CXX11
inline void SequencesOption::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.robot.SequencesOption.name)
}
#endif
inline void SequencesOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.robot.SequencesOption.name)
}
inline void SequencesOption::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.robot.SequencesOption.name)
}
inline ::std::string* SequencesOption::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:goldo.robot.SequencesOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SequencesOption::release_name() {
  // @@protoc_insertion_point(field_release:goldo.robot.SequencesOption.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SequencesOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.SequencesOption.name)
}

// bool default_bool = 2;
inline bool SequencesOption::has_default_bool() const {
  return default_value_case() == kDefaultBool;
}
inline void SequencesOption::set_has_default_bool() {
  _oneof_case_[0] = kDefaultBool;
}
inline void SequencesOption::clear_default_bool() {
  if (has_default_bool()) {
    default_value_.default_bool_ = false;
    clear_has_default_value();
  }
}
inline bool SequencesOption::default_bool() const {
  // @@protoc_insertion_point(field_get:goldo.robot.SequencesOption.default_bool)
  if (has_default_bool()) {
    return default_value_.default_bool_;
  }
  return false;
}
inline void SequencesOption::set_default_bool(bool value) {
  if (!has_default_bool()) {
    clear_default_value();
    set_has_default_bool();
  }
  default_value_.default_bool_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.SequencesOption.default_bool)
}

inline bool SequencesOption::has_default_value() const {
  return default_value_case() != DEFAULT_VALUE_NOT_SET;
}
inline void SequencesOption::clear_has_default_value() {
  _oneof_case_[0] = DEFAULT_VALUE_NOT_SET;
}
inline SequencesOption::DefaultValueCase SequencesOption::default_value_case() const {
  return SequencesOption::DefaultValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RobotConfig

// .goldo.nucleo.NucleoConfig nucleo = 1;
inline bool RobotConfig::has_nucleo() const {
  return this != internal_default_instance() && nucleo_ != NULL;
}
inline const ::goldo::nucleo::NucleoConfig& RobotConfig::_internal_nucleo() const {
  return *nucleo_;
}
inline const ::goldo::nucleo::NucleoConfig& RobotConfig::nucleo() const {
  const ::goldo::nucleo::NucleoConfig* p = nucleo_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.nucleo)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::NucleoConfig*>(
      &::goldo::nucleo::_NucleoConfig_default_instance_);
}
inline ::goldo::nucleo::NucleoConfig* RobotConfig::release_nucleo() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotConfig.nucleo)
  
  ::goldo::nucleo::NucleoConfig* temp = nucleo_;
  nucleo_ = NULL;
  return temp;
}
inline ::goldo::nucleo::NucleoConfig* RobotConfig::mutable_nucleo() {
  
  if (nucleo_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::NucleoConfig>(GetArenaNoVirtual());
    nucleo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.nucleo)
  return nucleo_;
}
inline void RobotConfig::set_allocated_nucleo(::goldo::nucleo::NucleoConfig* nucleo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(nucleo_);
  }
  if (nucleo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nucleo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nucleo, submessage_arena);
    }
    
  } else {
    
  }
  nucleo_ = nucleo;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotConfig.nucleo)
}

// .goldo.robot.RobotGeometry robot_geometry = 2;
inline bool RobotConfig::has_robot_geometry() const {
  return this != internal_default_instance() && robot_geometry_ != NULL;
}
inline void RobotConfig::clear_robot_geometry() {
  if (GetArenaNoVirtual() == NULL && robot_geometry_ != NULL) {
    delete robot_geometry_;
  }
  robot_geometry_ = NULL;
}
inline const ::goldo::robot::RobotGeometry& RobotConfig::_internal_robot_geometry() const {
  return *robot_geometry_;
}
inline const ::goldo::robot::RobotGeometry& RobotConfig::robot_geometry() const {
  const ::goldo::robot::RobotGeometry* p = robot_geometry_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.robot_geometry)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::robot::RobotGeometry*>(
      &::goldo::robot::_RobotGeometry_default_instance_);
}
inline ::goldo::robot::RobotGeometry* RobotConfig::release_robot_geometry() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotConfig.robot_geometry)
  
  ::goldo::robot::RobotGeometry* temp = robot_geometry_;
  robot_geometry_ = NULL;
  return temp;
}
inline ::goldo::robot::RobotGeometry* RobotConfig::mutable_robot_geometry() {
  
  if (robot_geometry_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::robot::RobotGeometry>(GetArenaNoVirtual());
    robot_geometry_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.robot_geometry)
  return robot_geometry_;
}
inline void RobotConfig::set_allocated_robot_geometry(::goldo::robot::RobotGeometry* robot_geometry) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete robot_geometry_;
  }
  if (robot_geometry) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot_geometry = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_geometry, submessage_arena);
    }
    
  } else {
    
  }
  robot_geometry_ = robot_geometry;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotConfig.robot_geometry)
}

// repeated string sequences_names = 40;
inline int RobotConfig::sequences_names_size() const {
  return sequences_names_.size();
}
inline void RobotConfig::clear_sequences_names() {
  sequences_names_.Clear();
}
inline const ::std::string& RobotConfig::sequences_names(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.sequences_names)
  return sequences_names_.Get(index);
}
inline ::std::string* RobotConfig::mutable_sequences_names(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.sequences_names)
  return sequences_names_.Mutable(index);
}
inline void RobotConfig::set_sequences_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:goldo.robot.RobotConfig.sequences_names)
  sequences_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RobotConfig::set_sequences_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:goldo.robot.RobotConfig.sequences_names)
  sequences_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RobotConfig::set_sequences_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sequences_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:goldo.robot.RobotConfig.sequences_names)
}
inline void RobotConfig::set_sequences_names(int index, const char* value, size_t size) {
  sequences_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:goldo.robot.RobotConfig.sequences_names)
}
inline ::std::string* RobotConfig::add_sequences_names() {
  // @@protoc_insertion_point(field_add_mutable:goldo.robot.RobotConfig.sequences_names)
  return sequences_names_.Add();
}
inline void RobotConfig::add_sequences_names(const ::std::string& value) {
  sequences_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:goldo.robot.RobotConfig.sequences_names)
}
#if LANG_CXX11
inline void RobotConfig::add_sequences_names(::std::string&& value) {
  sequences_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:goldo.robot.RobotConfig.sequences_names)
}
#endif
inline void RobotConfig::add_sequences_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sequences_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:goldo.robot.RobotConfig.sequences_names)
}
inline void RobotConfig::add_sequences_names(const char* value, size_t size) {
  sequences_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:goldo.robot.RobotConfig.sequences_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RobotConfig::sequences_names() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RobotConfig.sequences_names)
  return sequences_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RobotConfig::mutable_sequences_names() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RobotConfig.sequences_names)
  return &sequences_names_;
}

// repeated .goldo.robot.SequencesFile sequences_files = 41;
inline int RobotConfig::sequences_files_size() const {
  return sequences_files_.size();
}
inline void RobotConfig::clear_sequences_files() {
  sequences_files_.Clear();
}
inline ::goldo::robot::SequencesFile* RobotConfig::mutable_sequences_files(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.sequences_files)
  return sequences_files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesFile >*
RobotConfig::mutable_sequences_files() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RobotConfig.sequences_files)
  return &sequences_files_;
}
inline const ::goldo::robot::SequencesFile& RobotConfig::sequences_files(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.sequences_files)
  return sequences_files_.Get(index);
}
inline ::goldo::robot::SequencesFile* RobotConfig::add_sequences_files() {
  // @@protoc_insertion_point(field_add:goldo.robot.RobotConfig.sequences_files)
  return sequences_files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesFile >&
RobotConfig::sequences_files() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RobotConfig.sequences_files)
  return sequences_files_;
}

// repeated .goldo.robot.SequencesOption sequences_options = 42;
inline int RobotConfig::sequences_options_size() const {
  return sequences_options_.size();
}
inline void RobotConfig::clear_sequences_options() {
  sequences_options_.Clear();
}
inline ::goldo::robot::SequencesOption* RobotConfig::mutable_sequences_options(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.sequences_options)
  return sequences_options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesOption >*
RobotConfig::mutable_sequences_options() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RobotConfig.sequences_options)
  return &sequences_options_;
}
inline const ::goldo::robot::SequencesOption& RobotConfig::sequences_options(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.sequences_options)
  return sequences_options_.Get(index);
}
inline ::goldo::robot::SequencesOption* RobotConfig::add_sequences_options() {
  // @@protoc_insertion_point(field_add:goldo.robot.RobotConfig.sequences_options)
  return sequences_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::robot::SequencesOption >&
RobotConfig::sequences_options() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RobotConfig.sequences_options)
  return sequences_options_;
}

// .goldo.rplidar.RPLidarConfig rplidar = 50;
inline bool RobotConfig::has_rplidar() const {
  return this != internal_default_instance() && rplidar_ != NULL;
}
inline const ::goldo::rplidar::RPLidarConfig& RobotConfig::_internal_rplidar() const {
  return *rplidar_;
}
inline const ::goldo::rplidar::RPLidarConfig& RobotConfig::rplidar() const {
  const ::goldo::rplidar::RPLidarConfig* p = rplidar_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.rplidar)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::rplidar::RPLidarConfig*>(
      &::goldo::rplidar::_RPLidarConfig_default_instance_);
}
inline ::goldo::rplidar::RPLidarConfig* RobotConfig::release_rplidar() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotConfig.rplidar)
  
  ::goldo::rplidar::RPLidarConfig* temp = rplidar_;
  rplidar_ = NULL;
  return temp;
}
inline ::goldo::rplidar::RPLidarConfig* RobotConfig::mutable_rplidar() {
  
  if (rplidar_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::rplidar::RPLidarConfig>(GetArenaNoVirtual());
    rplidar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.rplidar)
  return rplidar_;
}
inline void RobotConfig::set_allocated_rplidar(::goldo::rplidar::RPLidarConfig* rplidar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rplidar_);
  }
  if (rplidar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rplidar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rplidar, submessage_arena);
    }
    
  } else {
    
  }
  rplidar_ = rplidar;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotConfig.rplidar)
}

// .goldo.strategy.StrategyConfig strategy = 60;
inline bool RobotConfig::has_strategy() const {
  return this != internal_default_instance() && strategy_ != NULL;
}
inline const ::goldo::strategy::StrategyConfig& RobotConfig::_internal_strategy() const {
  return *strategy_;
}
inline const ::goldo::strategy::StrategyConfig& RobotConfig::strategy() const {
  const ::goldo::strategy::StrategyConfig* p = strategy_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotConfig.strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::strategy::StrategyConfig*>(
      &::goldo::strategy::_StrategyConfig_default_instance_);
}
inline ::goldo::strategy::StrategyConfig* RobotConfig::release_strategy() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotConfig.strategy)
  
  ::goldo::strategy::StrategyConfig* temp = strategy_;
  strategy_ = NULL;
  return temp;
}
inline ::goldo::strategy::StrategyConfig* RobotConfig::mutable_strategy() {
  
  if (strategy_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::strategy::StrategyConfig>(GetArenaNoVirtual());
    strategy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotConfig.strategy)
  return strategy_;
}
inline void RobotConfig::set_allocated_strategy(::goldo::strategy::StrategyConfig* strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(strategy_);
  }
  if (strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, strategy, submessage_arena);
    }
    
  } else {
    
  }
  strategy_ = strategy;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotConfig.strategy)
}

// -------------------------------------------------------------------

// RPLidarState

// bool running = 1;
inline void RPLidarState::clear_running() {
  running_ = false;
}
inline bool RPLidarState::running() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RPLidarState.running)
  return running_;
}
inline void RPLidarState::set_running(bool value) {
  
  running_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RPLidarState.running)
}

// repeated .goldo.rplidar.RobotDetection detections = 10;
inline int RPLidarState::detections_size() const {
  return detections_.size();
}
inline ::goldo::rplidar::RobotDetection* RPLidarState::mutable_detections(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RPLidarState.detections)
  return detections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >*
RPLidarState::mutable_detections() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RPLidarState.detections)
  return &detections_;
}
inline const ::goldo::rplidar::RobotDetection& RPLidarState::detections(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RPLidarState.detections)
  return detections_.Get(index);
}
inline ::goldo::rplidar::RobotDetection* RPLidarState::add_detections() {
  // @@protoc_insertion_point(field_add:goldo.robot.RPLidarState.detections)
  return detections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >&
RPLidarState::detections() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RPLidarState.detections)
  return detections_;
}

// .goldo.rplidar.Zones zones = 11;
inline bool RPLidarState::has_zones() const {
  return this != internal_default_instance() && zones_ != NULL;
}
inline const ::goldo::rplidar::Zones& RPLidarState::_internal_zones() const {
  return *zones_;
}
inline const ::goldo::rplidar::Zones& RPLidarState::zones() const {
  const ::goldo::rplidar::Zones* p = zones_;
  // @@protoc_insertion_point(field_get:goldo.robot.RPLidarState.zones)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::rplidar::Zones*>(
      &::goldo::rplidar::_Zones_default_instance_);
}
inline ::goldo::rplidar::Zones* RPLidarState::release_zones() {
  // @@protoc_insertion_point(field_release:goldo.robot.RPLidarState.zones)
  
  ::goldo::rplidar::Zones* temp = zones_;
  zones_ = NULL;
  return temp;
}
inline ::goldo::rplidar::Zones* RPLidarState::mutable_zones() {
  
  if (zones_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::rplidar::Zones>(GetArenaNoVirtual());
    zones_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RPLidarState.zones)
  return zones_;
}
inline void RPLidarState::set_allocated_zones(::goldo::rplidar::Zones* zones) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(zones_);
  }
  if (zones) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      zones = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, zones, submessage_arena);
    }
    
  } else {
    
  }
  zones_ = zones;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RPLidarState.zones)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RobotState

// .goldo.nucleo.NucleoState nucleo = 1;
inline bool RobotState::has_nucleo() const {
  return this != internal_default_instance() && nucleo_ != NULL;
}
inline const ::goldo::nucleo::NucleoState& RobotState::_internal_nucleo() const {
  return *nucleo_;
}
inline const ::goldo::nucleo::NucleoState& RobotState::nucleo() const {
  const ::goldo::nucleo::NucleoState* p = nucleo_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.nucleo)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::NucleoState*>(
      &::goldo::nucleo::_NucleoState_default_instance_);
}
inline ::goldo::nucleo::NucleoState* RobotState::release_nucleo() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotState.nucleo)
  
  ::goldo::nucleo::NucleoState* temp = nucleo_;
  nucleo_ = NULL;
  return temp;
}
inline ::goldo::nucleo::NucleoState* RobotState::mutable_nucleo() {
  
  if (nucleo_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::NucleoState>(GetArenaNoVirtual());
    nucleo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotState.nucleo)
  return nucleo_;
}
inline void RobotState::set_allocated_nucleo(::goldo::nucleo::NucleoState* nucleo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(nucleo_);
  }
  if (nucleo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nucleo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nucleo, submessage_arena);
    }
    
  } else {
    
  }
  nucleo_ = nucleo;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotState.nucleo)
}

// map<string, bool> sensors = 2;
inline int RobotState::sensors_size() const {
  return sensors_.size();
}
inline void RobotState::clear_sensors() {
  sensors_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, bool >&
RobotState::sensors() const {
  // @@protoc_insertion_point(field_map:goldo.robot.RobotState.sensors)
  return sensors_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, bool >*
RobotState::mutable_sensors() {
  // @@protoc_insertion_point(field_mutable_map:goldo.robot.RobotState.sensors)
  return sensors_.MutableMap();
}

// .goldo.table.TableState table = 3;
inline bool RobotState::has_table() const {
  return this != internal_default_instance() && table_ != NULL;
}
inline const ::goldo::table::TableState& RobotState::_internal_table() const {
  return *table_;
}
inline const ::goldo::table::TableState& RobotState::table() const {
  const ::goldo::table::TableState* p = table_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.table)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::table::TableState*>(
      &::goldo::table::_TableState_default_instance_);
}
inline ::goldo::table::TableState* RobotState::release_table() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotState.table)
  
  ::goldo::table::TableState* temp = table_;
  table_ = NULL;
  return temp;
}
inline ::goldo::table::TableState* RobotState::mutable_table() {
  
  if (table_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::table::TableState>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotState.table)
  return table_;
}
inline void RobotState::set_allocated_table(::goldo::table::TableState* table) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(table_);
  }
  if (table) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    
  } else {
    
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotState.table)
}

// bool emergency_stop = 4;
inline void RobotState::clear_emergency_stop() {
  emergency_stop_ = false;
}
inline bool RobotState::emergency_stop() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.emergency_stop)
  return emergency_stop_;
}
inline void RobotState::set_emergency_stop(bool value) {
  
  emergency_stop_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.emergency_stop)
}

// uint32 score = 5;
inline void RobotState::clear_score() {
  score_ = 0u;
}
inline ::google::protobuf::uint32 RobotState::score() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.score)
  return score_;
}
inline void RobotState::set_score(::google::protobuf::uint32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.score)
}

// uint32 match_timer = 6;
inline void RobotState::clear_match_timer() {
  match_timer_ = 0u;
}
inline ::google::protobuf::uint32 RobotState::match_timer() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.match_timer)
  return match_timer_;
}
inline void RobotState::set_match_timer(::google::protobuf::uint32 value) {
  
  match_timer_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.match_timer)
}

// .goldo.robot.Side side = 7;
inline void RobotState::clear_side() {
  side_ = 0;
}
inline ::goldo::robot::Side RobotState::side() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.side)
  return static_cast< ::goldo::robot::Side >(side_);
}
inline void RobotState::set_side(::goldo::robot::Side value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.side)
}

// .goldo.common.geometry.Pose robot_pose = 8;
inline bool RobotState::has_robot_pose() const {
  return this != internal_default_instance() && robot_pose_ != NULL;
}
inline const ::goldo::common::geometry::Pose& RobotState::_internal_robot_pose() const {
  return *robot_pose_;
}
inline const ::goldo::common::geometry::Pose& RobotState::robot_pose() const {
  const ::goldo::common::geometry::Pose* p = robot_pose_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.robot_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Pose*>(
      &::goldo::common::geometry::_Pose_default_instance_);
}
inline ::goldo::common::geometry::Pose* RobotState::release_robot_pose() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotState.robot_pose)
  
  ::goldo::common::geometry::Pose* temp = robot_pose_;
  robot_pose_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Pose* RobotState::mutable_robot_pose() {
  
  if (robot_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Pose>(GetArenaNoVirtual());
    robot_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotState.robot_pose)
  return robot_pose_;
}
inline void RobotState::set_allocated_robot_pose(::goldo::common::geometry::Pose* robot_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(robot_pose_);
  }
  if (robot_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      robot_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, robot_pose, submessage_arena);
    }
    
  } else {
    
  }
  robot_pose_ = robot_pose;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotState.robot_pose)
}

// bool tirette = 9;
inline void RobotState::clear_tirette() {
  tirette_ = false;
}
inline bool RobotState::tirette() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.tirette)
  return tirette_;
}
inline void RobotState::set_tirette(bool value) {
  
  tirette_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.tirette)
}

// repeated .goldo.rplidar.RobotDetection rplidar_detections = 10;
inline int RobotState::rplidar_detections_size() const {
  return rplidar_detections_.size();
}
inline ::goldo::rplidar::RobotDetection* RobotState::mutable_rplidar_detections(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotState.rplidar_detections)
  return rplidar_detections_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >*
RobotState::mutable_rplidar_detections() {
  // @@protoc_insertion_point(field_mutable_list:goldo.robot.RobotState.rplidar_detections)
  return &rplidar_detections_;
}
inline const ::goldo::rplidar::RobotDetection& RobotState::rplidar_detections(int index) const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.rplidar_detections)
  return rplidar_detections_.Get(index);
}
inline ::goldo::rplidar::RobotDetection* RobotState::add_rplidar_detections() {
  // @@protoc_insertion_point(field_add:goldo.robot.RobotState.rplidar_detections)
  return rplidar_detections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::rplidar::RobotDetection >&
RobotState::rplidar_detections() const {
  // @@protoc_insertion_point(field_list:goldo.robot.RobotState.rplidar_detections)
  return rplidar_detections_;
}

// .goldo.robot.RPLidarState rplidar = 11;
inline bool RobotState::has_rplidar() const {
  return this != internal_default_instance() && rplidar_ != NULL;
}
inline void RobotState::clear_rplidar() {
  if (GetArenaNoVirtual() == NULL && rplidar_ != NULL) {
    delete rplidar_;
  }
  rplidar_ = NULL;
}
inline const ::goldo::robot::RPLidarState& RobotState::_internal_rplidar() const {
  return *rplidar_;
}
inline const ::goldo::robot::RPLidarState& RobotState::rplidar() const {
  const ::goldo::robot::RPLidarState* p = rplidar_;
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.rplidar)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::robot::RPLidarState*>(
      &::goldo::robot::_RPLidarState_default_instance_);
}
inline ::goldo::robot::RPLidarState* RobotState::release_rplidar() {
  // @@protoc_insertion_point(field_release:goldo.robot.RobotState.rplidar)
  
  ::goldo::robot::RPLidarState* temp = rplidar_;
  rplidar_ = NULL;
  return temp;
}
inline ::goldo::robot::RPLidarState* RobotState::mutable_rplidar() {
  
  if (rplidar_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::robot::RPLidarState>(GetArenaNoVirtual());
    rplidar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.robot.RobotState.rplidar)
  return rplidar_;
}
inline void RobotState::set_allocated_rplidar(::goldo::robot::RPLidarState* rplidar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rplidar_;
  }
  if (rplidar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rplidar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rplidar, submessage_arena);
    }
    
  } else {
    
  }
  rplidar_ = rplidar;
  // @@protoc_insertion_point(field_set_allocated:goldo.robot.RobotState.rplidar)
}

// .goldo.robot.MatchState match_state = 12;
inline void RobotState::clear_match_state() {
  match_state_ = 0;
}
inline ::goldo::robot::MatchState RobotState::match_state() const {
  // @@protoc_insertion_point(field_get:goldo.robot.RobotState.match_state)
  return static_cast< ::goldo::robot::MatchState >(match_state_);
}
inline void RobotState::set_match_state(::goldo::robot::MatchState value) {
  
  match_state_ = value;
  // @@protoc_insertion_point(field_set:goldo.robot.RobotState.match_state)
}

// map<string, .goldo.nucleo.servos.ServoState> servos = 13;
inline int RobotState::servos_size() const {
  return servos_.size();
}
inline const ::google::protobuf::Map< ::std::string, ::goldo::nucleo::servos::ServoState >&
RobotState::servos() const {
  // @@protoc_insertion_point(field_map:goldo.robot.RobotState.servos)
  return servos_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::goldo::nucleo::servos::ServoState >*
RobotState::mutable_servos() {
  // @@protoc_insertion_point(field_mutable_map:goldo.robot.RobotState.servos)
  return servos_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot
}  // namespace goldo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::goldo::robot::Side> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::robot::Side>() {
  return ::goldo::robot::Side_descriptor();
}
template <> struct is_proto_enum< ::goldo::robot::MatchState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::robot::MatchState>() {
  return ::goldo::robot::MatchState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2frobot_2eproto
