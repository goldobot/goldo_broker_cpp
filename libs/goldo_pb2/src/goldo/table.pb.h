// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/table.proto

#ifndef PROTOBUF_INCLUDED_goldo_2ftable_2eproto
#define PROTOBUF_INCLUDED_goldo_2ftable_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "goldo/common/geometry.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2ftable_2eproto 

namespace protobuf_goldo_2ftable_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2ftable_2eproto
namespace goldo {
namespace table {
class CupState;
class CupStateDefaultTypeInternal;
extern CupStateDefaultTypeInternal _CupState_default_instance_;
class ReefState;
class ReefStateDefaultTypeInternal;
extern ReefStateDefaultTypeInternal _ReefState_default_instance_;
class TableState;
class TableStateDefaultTypeInternal;
extern TableStateDefaultTypeInternal _TableState_default_instance_;
class TableState_ReefsEntry_DoNotUse;
class TableState_ReefsEntry_DoNotUseDefaultTypeInternal;
extern TableState_ReefsEntry_DoNotUseDefaultTypeInternal _TableState_ReefsEntry_DoNotUse_default_instance_;
}  // namespace table
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::table::CupState* Arena::CreateMaybeMessage<::goldo::table::CupState>(Arena*);
template<> ::goldo::table::ReefState* Arena::CreateMaybeMessage<::goldo::table::ReefState>(Arena*);
template<> ::goldo::table::TableState* Arena::CreateMaybeMessage<::goldo::table::TableState>(Arena*);
template<> ::goldo::table::TableState_ReefsEntry_DoNotUse* Arena::CreateMaybeMessage<::goldo::table::TableState_ReefsEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace table {

enum CupType {
  CUP_TYPE__UNKNOWN = 0,
  CUP_TYPE_GREEN = 1,
  CUP_TYPE_RED = 2,
  CupType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CupType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CupType_IsValid(int value);
const CupType CupType_MIN = CUP_TYPE__UNKNOWN;
const CupType CupType_MAX = CUP_TYPE_RED;
const int CupType_ARRAYSIZE = CupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CupType_descriptor();
inline const ::std::string& CupType_Name(CupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CupType_descriptor(), value);
}
inline bool CupType_Parse(
    const ::std::string& name, CupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CupType>(
    CupType_descriptor(), name, value);
}
enum CupOrientation {
  CUP_ORIENTATION_UNKNOWN = 0,
  CUP_ORIENTATION_STANDING = 1,
  CUP_ORIENTATION_UPTURNED = 2,
  CupOrientation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CupOrientation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CupOrientation_IsValid(int value);
const CupOrientation CupOrientation_MIN = CUP_ORIENTATION_UNKNOWN;
const CupOrientation CupOrientation_MAX = CUP_ORIENTATION_UPTURNED;
const int CupOrientation_ARRAYSIZE = CupOrientation_MAX + 1;

const ::google::protobuf::EnumDescriptor* CupOrientation_descriptor();
inline const ::std::string& CupOrientation_Name(CupOrientation value) {
  return ::google::protobuf::internal::NameOfEnum(
    CupOrientation_descriptor(), value);
}
inline bool CupOrientation_Parse(
    const ::std::string& name, CupOrientation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CupOrientation>(
    CupOrientation_descriptor(), name, value);
}
enum WindsockState {
  WINDSOCK_UNKNOWN = 0,
  WINDSOCK_UP = 1,
  WINDSOCK_DOWN = 2,
  WindsockState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WindsockState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WindsockState_IsValid(int value);
const WindsockState WindsockState_MIN = WINDSOCK_UNKNOWN;
const WindsockState WindsockState_MAX = WINDSOCK_DOWN;
const int WindsockState_ARRAYSIZE = WindsockState_MAX + 1;

const ::google::protobuf::EnumDescriptor* WindsockState_descriptor();
inline const ::std::string& WindsockState_Name(WindsockState value) {
  return ::google::protobuf::internal::NameOfEnum(
    WindsockState_descriptor(), value);
}
inline bool WindsockState_Parse(
    const ::std::string& name, WindsockState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WindsockState>(
    WindsockState_descriptor(), name, value);
}
enum CompassState {
  COMPASS_UNKNOWN = 0,
  COMPASS_NORTH = 1,
  COMPASS_SOUTH = 2,
  CompassState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CompassState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CompassState_IsValid(int value);
const CompassState CompassState_MIN = COMPASS_UNKNOWN;
const CompassState CompassState_MAX = COMPASS_SOUTH;
const int CompassState_ARRAYSIZE = CompassState_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompassState_descriptor();
inline const ::std::string& CompassState_Name(CompassState value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompassState_descriptor(), value);
}
inline bool CompassState_Parse(
    const ::std::string& name, CompassState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompassState>(
    CompassState_descriptor(), name, value);
}
// ===================================================================

class CupState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.table.CupState) */ {
 public:
  CupState();
  virtual ~CupState();

  CupState(const CupState& from);

  inline CupState& operator=(const CupState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CupState(CupState&& from) noexcept
    : CupState() {
    *this = ::std::move(from);
  }

  inline CupState& operator=(CupState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CupState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CupState* internal_default_instance() {
    return reinterpret_cast<const CupState*>(
               &_CupState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CupState* other);
  friend void swap(CupState& a, CupState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CupState* New() const final {
    return CreateMaybeMessage<CupState>(NULL);
  }

  CupState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CupState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CupState& from);
  void MergeFrom(const CupState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CupState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  private:
  const ::goldo::common::geometry::Point& _internal_position() const;
  public:
  const ::goldo::common::geometry::Point& position() const;
  ::goldo::common::geometry::Point* release_position();
  ::goldo::common::geometry::Point* mutable_position();
  void set_allocated_position(::goldo::common::geometry::Point* position);

  // .goldo.table.CupType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::goldo::table::CupType type() const;
  void set_type(::goldo::table::CupType value);

  // .goldo.table.CupOrientation orientation = 2;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  ::goldo::table::CupOrientation orientation() const;
  void set_orientation(::goldo::table::CupOrientation value);

  // @@protoc_insertion_point(class_scope:goldo.table.CupState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* position_;
  int type_;
  int orientation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2ftable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReefState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.table.ReefState) */ {
 public:
  ReefState();
  virtual ~ReefState();

  ReefState(const ReefState& from);

  inline ReefState& operator=(const ReefState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReefState(ReefState&& from) noexcept
    : ReefState() {
    *this = ::std::move(from);
  }

  inline ReefState& operator=(ReefState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReefState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReefState* internal_default_instance() {
    return reinterpret_cast<const ReefState*>(
               &_ReefState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ReefState* other);
  friend void swap(ReefState& a, ReefState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReefState* New() const final {
    return CreateMaybeMessage<ReefState>(NULL);
  }

  ReefState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReefState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReefState& from);
  void MergeFrom(const ReefState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReefState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.table.CupState cups = 1;
  int cups_size() const;
  void clear_cups();
  static const int kCupsFieldNumber = 1;
  ::goldo::table::CupState* mutable_cups(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::table::CupState >*
      mutable_cups();
  const ::goldo::table::CupState& cups(int index) const;
  ::goldo::table::CupState* add_cups();
  const ::google::protobuf::RepeatedPtrField< ::goldo::table::CupState >&
      cups() const;

  // @@protoc_insertion_point(class_scope:goldo.table.ReefState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::table::CupState > cups_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2ftable_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableState_ReefsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TableState_ReefsEntry_DoNotUse, 
    ::std::string, ::goldo::table::ReefState,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TableState_ReefsEntry_DoNotUse, 
    ::std::string, ::goldo::table::ReefState,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  TableState_ReefsEntry_DoNotUse();
  TableState_ReefsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TableState_ReefsEntry_DoNotUse& other);
  static const TableState_ReefsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TableState_ReefsEntry_DoNotUse*>(&_TableState_ReefsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TableState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.table.TableState) */ {
 public:
  TableState();
  virtual ~TableState();

  TableState(const TableState& from);

  inline TableState& operator=(const TableState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableState(TableState&& from) noexcept
    : TableState() {
    *this = ::std::move(from);
  }

  inline TableState& operator=(TableState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TableState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableState* internal_default_instance() {
    return reinterpret_cast<const TableState*>(
               &_TableState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TableState* other);
  friend void swap(TableState& a, TableState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableState* New() const final {
    return CreateMaybeMessage<TableState>(NULL);
  }

  TableState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableState& from);
  void MergeFrom(const TableState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .goldo.table.ReefState> reefs = 1;
  int reefs_size() const;
  void clear_reefs();
  static const int kReefsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::goldo::table::ReefState >&
      reefs() const;
  ::google::protobuf::Map< ::std::string, ::goldo::table::ReefState >*
      mutable_reefs();

  // .goldo.table.CupState cups = 2;
  bool has_cups() const;
  void clear_cups();
  static const int kCupsFieldNumber = 2;
  private:
  const ::goldo::table::CupState& _internal_cups() const;
  public:
  const ::goldo::table::CupState& cups() const;
  ::goldo::table::CupState* release_cups();
  ::goldo::table::CupState* mutable_cups();
  void set_allocated_cups(::goldo::table::CupState* cups);

  // .goldo.table.CompassState compas = 3;
  void clear_compas();
  static const int kCompasFieldNumber = 3;
  ::goldo::table::CompassState compas() const;
  void set_compas(::goldo::table::CompassState value);

  // @@protoc_insertion_point(class_scope:goldo.table.TableState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TableState_ReefsEntry_DoNotUse,
      ::std::string, ::goldo::table::ReefState,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > reefs_;
  ::goldo::table::CupState* cups_;
  int compas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2ftable_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CupState

// .goldo.table.CupType type = 1;
inline void CupState::clear_type() {
  type_ = 0;
}
inline ::goldo::table::CupType CupState::type() const {
  // @@protoc_insertion_point(field_get:goldo.table.CupState.type)
  return static_cast< ::goldo::table::CupType >(type_);
}
inline void CupState::set_type(::goldo::table::CupType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:goldo.table.CupState.type)
}

// .goldo.table.CupOrientation orientation = 2;
inline void CupState::clear_orientation() {
  orientation_ = 0;
}
inline ::goldo::table::CupOrientation CupState::orientation() const {
  // @@protoc_insertion_point(field_get:goldo.table.CupState.orientation)
  return static_cast< ::goldo::table::CupOrientation >(orientation_);
}
inline void CupState::set_orientation(::goldo::table::CupOrientation value) {
  
  orientation_ = value;
  // @@protoc_insertion_point(field_set:goldo.table.CupState.orientation)
}

// .goldo.common.geometry.Point position = 3;
inline bool CupState::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::goldo::common::geometry::Point& CupState::_internal_position() const {
  return *position_;
}
inline const ::goldo::common::geometry::Point& CupState::position() const {
  const ::goldo::common::geometry::Point* p = position_;
  // @@protoc_insertion_point(field_get:goldo.table.CupState.position)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* CupState::release_position() {
  // @@protoc_insertion_point(field_release:goldo.table.CupState.position)
  
  ::goldo::common::geometry::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* CupState::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.table.CupState.position)
  return position_;
}
inline void CupState::set_allocated_position(::goldo::common::geometry::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:goldo.table.CupState.position)
}

// -------------------------------------------------------------------

// ReefState

// repeated .goldo.table.CupState cups = 1;
inline int ReefState::cups_size() const {
  return cups_.size();
}
inline void ReefState::clear_cups() {
  cups_.Clear();
}
inline ::goldo::table::CupState* ReefState::mutable_cups(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.table.ReefState.cups)
  return cups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::table::CupState >*
ReefState::mutable_cups() {
  // @@protoc_insertion_point(field_mutable_list:goldo.table.ReefState.cups)
  return &cups_;
}
inline const ::goldo::table::CupState& ReefState::cups(int index) const {
  // @@protoc_insertion_point(field_get:goldo.table.ReefState.cups)
  return cups_.Get(index);
}
inline ::goldo::table::CupState* ReefState::add_cups() {
  // @@protoc_insertion_point(field_add:goldo.table.ReefState.cups)
  return cups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::table::CupState >&
ReefState::cups() const {
  // @@protoc_insertion_point(field_list:goldo.table.ReefState.cups)
  return cups_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TableState

// map<string, .goldo.table.ReefState> reefs = 1;
inline int TableState::reefs_size() const {
  return reefs_.size();
}
inline void TableState::clear_reefs() {
  reefs_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::goldo::table::ReefState >&
TableState::reefs() const {
  // @@protoc_insertion_point(field_map:goldo.table.TableState.reefs)
  return reefs_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::goldo::table::ReefState >*
TableState::mutable_reefs() {
  // @@protoc_insertion_point(field_mutable_map:goldo.table.TableState.reefs)
  return reefs_.MutableMap();
}

// .goldo.table.CupState cups = 2;
inline bool TableState::has_cups() const {
  return this != internal_default_instance() && cups_ != NULL;
}
inline void TableState::clear_cups() {
  if (GetArenaNoVirtual() == NULL && cups_ != NULL) {
    delete cups_;
  }
  cups_ = NULL;
}
inline const ::goldo::table::CupState& TableState::_internal_cups() const {
  return *cups_;
}
inline const ::goldo::table::CupState& TableState::cups() const {
  const ::goldo::table::CupState* p = cups_;
  // @@protoc_insertion_point(field_get:goldo.table.TableState.cups)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::table::CupState*>(
      &::goldo::table::_CupState_default_instance_);
}
inline ::goldo::table::CupState* TableState::release_cups() {
  // @@protoc_insertion_point(field_release:goldo.table.TableState.cups)
  
  ::goldo::table::CupState* temp = cups_;
  cups_ = NULL;
  return temp;
}
inline ::goldo::table::CupState* TableState::mutable_cups() {
  
  if (cups_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::table::CupState>(GetArenaNoVirtual());
    cups_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.table.TableState.cups)
  return cups_;
}
inline void TableState::set_allocated_cups(::goldo::table::CupState* cups) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cups_;
  }
  if (cups) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cups = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cups, submessage_arena);
    }
    
  } else {
    
  }
  cups_ = cups;
  // @@protoc_insertion_point(field_set_allocated:goldo.table.TableState.cups)
}

// .goldo.table.CompassState compas = 3;
inline void TableState::clear_compas() {
  compas_ = 0;
}
inline ::goldo::table::CompassState TableState::compas() const {
  // @@protoc_insertion_point(field_get:goldo.table.TableState.compas)
  return static_cast< ::goldo::table::CompassState >(compas_);
}
inline void TableState::set_compas(::goldo::table::CompassState value) {
  
  compas_ = value;
  // @@protoc_insertion_point(field_set:goldo.table.TableState.compas)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace table
}  // namespace goldo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::goldo::table::CupType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::table::CupType>() {
  return ::goldo::table::CupType_descriptor();
}
template <> struct is_proto_enum< ::goldo::table::CupOrientation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::table::CupOrientation>() {
  return ::goldo::table::CupOrientation_descriptor();
}
template <> struct is_proto_enum< ::goldo::table::WindsockState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::table::WindsockState>() {
  return ::goldo::table::WindsockState_descriptor();
}
template <> struct is_proto_enum< ::goldo::table::CompassState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::table::CompassState>() {
  return ::goldo::table::CompassState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2ftable_2eproto
