// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/strategy.proto

#ifndef PROTOBUF_INCLUDED_goldo_2fstrategy_2eproto
#define PROTOBUF_INCLUDED_goldo_2fstrategy_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "goldo/common/geometry.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2fstrategy_2eproto 

namespace protobuf_goldo_2fstrategy_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2fstrategy_2eproto
namespace goldo {
namespace strategy {
class ActionConfig;
class ActionConfigDefaultTypeInternal;
extern ActionConfigDefaultTypeInternal _ActionConfig_default_instance_;
class Area;
class AreaDefaultTypeInternal;
extern AreaDefaultTypeInternal _Area_default_instance_;
class StrategyConfig;
class StrategyConfigDefaultTypeInternal;
extern StrategyConfigDefaultTypeInternal _StrategyConfig_default_instance_;
class StrategyConfig_ActionsEntry_DoNotUse;
class StrategyConfig_ActionsEntry_DoNotUseDefaultTypeInternal;
extern StrategyConfig_ActionsEntry_DoNotUseDefaultTypeInternal _StrategyConfig_ActionsEntry_DoNotUse_default_instance_;
class StrategyState;
class StrategyStateDefaultTypeInternal;
extern StrategyStateDefaultTypeInternal _StrategyState_default_instance_;
}  // namespace strategy
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::strategy::ActionConfig* Arena::CreateMaybeMessage<::goldo::strategy::ActionConfig>(Arena*);
template<> ::goldo::strategy::Area* Arena::CreateMaybeMessage<::goldo::strategy::Area>(Arena*);
template<> ::goldo::strategy::StrategyConfig* Arena::CreateMaybeMessage<::goldo::strategy::StrategyConfig>(Arena*);
template<> ::goldo::strategy::StrategyConfig_ActionsEntry_DoNotUse* Arena::CreateMaybeMessage<::goldo::strategy::StrategyConfig_ActionsEntry_DoNotUse>(Arena*);
template<> ::goldo::strategy::StrategyState* Arena::CreateMaybeMessage<::goldo::strategy::StrategyState>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace strategy {

// ===================================================================

class Area : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.strategy.Area) */ {
 public:
  Area();
  virtual ~Area();

  Area(const Area& from);

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Area(Area&& from) noexcept
    : Area() {
    *this = ::std::move(from);
  }

  inline Area& operator=(Area&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Area& default_instance();

  enum GeometryCase {
    kBox = 2,
    kCircle = 3,
    kPolygo = 4,
    GEOMETRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Area* internal_default_instance() {
    return reinterpret_cast<const Area*>(
               &_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Area* other);
  friend void swap(Area& a, Area& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Area* New() const final {
    return CreateMaybeMessage<Area>(NULL);
  }

  Area* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Area>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Area* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .goldo.common.geometry.Box box = 2;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Box& _internal_box() const;
  public:
  const ::goldo::common::geometry::Box& box() const;
  ::goldo::common::geometry::Box* release_box();
  ::goldo::common::geometry::Box* mutable_box();
  void set_allocated_box(::goldo::common::geometry::Box* box);

  // .goldo.common.geometry.Circle circle = 3;
  bool has_circle() const;
  void clear_circle();
  static const int kCircleFieldNumber = 3;
  private:
  const ::goldo::common::geometry::Circle& _internal_circle() const;
  public:
  const ::goldo::common::geometry::Circle& circle() const;
  ::goldo::common::geometry::Circle* release_circle();
  ::goldo::common::geometry::Circle* mutable_circle();
  void set_allocated_circle(::goldo::common::geometry::Circle* circle);

  // .goldo.common.geometry.Polygon polygo = 4;
  bool has_polygo() const;
  void clear_polygo();
  static const int kPolygoFieldNumber = 4;
  private:
  const ::goldo::common::geometry::Polygon& _internal_polygo() const;
  public:
  const ::goldo::common::geometry::Polygon& polygo() const;
  ::goldo::common::geometry::Polygon* release_polygo();
  ::goldo::common::geometry::Polygon* mutable_polygo();
  void set_allocated_polygo(::goldo::common::geometry::Polygon* polygo);

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:goldo.strategy.Area)
 private:
  void set_has_box();
  void set_has_circle();
  void set_has_polygo();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union GeometryUnion {
    GeometryUnion() {}
    ::goldo::common::geometry::Box* box_;
    ::goldo::common::geometry::Circle* circle_;
    ::goldo::common::geometry::Polygon* polygo_;
  } geometry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_goldo_2fstrategy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActionConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.strategy.ActionConfig) */ {
 public:
  ActionConfig();
  virtual ~ActionConfig();

  ActionConfig(const ActionConfig& from);

  inline ActionConfig& operator=(const ActionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActionConfig(ActionConfig&& from) noexcept
    : ActionConfig() {
    *this = ::std::move(from);
  }

  inline ActionConfig& operator=(ActionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionConfig* internal_default_instance() {
    return reinterpret_cast<const ActionConfig*>(
               &_ActionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ActionConfig* other);
  friend void swap(ActionConfig& a, ActionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActionConfig* New() const final {
    return CreateMaybeMessage<ActionConfig>(NULL);
  }

  ActionConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActionConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActionConfig& from);
  void MergeFrom(const ActionConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sequence_action = 2;
  void clear_sequence_action();
  static const int kSequenceActionFieldNumber = 2;
  const ::std::string& sequence_action() const;
  void set_sequence_action(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence_action(::std::string&& value);
  #endif
  void set_sequence_action(const char* value);
  void set_sequence_action(const char* value, size_t size);
  ::std::string* mutable_sequence_action();
  ::std::string* release_sequence_action();
  void set_allocated_sequence_action(::std::string* sequence_action);

  // string sequence_prepare = 3;
  void clear_sequence_prepare();
  static const int kSequencePrepareFieldNumber = 3;
  const ::std::string& sequence_prepare() const;
  void set_sequence_prepare(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence_prepare(::std::string&& value);
  #endif
  void set_sequence_prepare(const char* value);
  void set_sequence_prepare(const char* value, size_t size);
  ::std::string* mutable_sequence_prepare();
  ::std::string* release_sequence_prepare();
  void set_allocated_sequence_prepare(::std::string* sequence_prepare);

  // string sequence_prepare_abort = 4;
  void clear_sequence_prepare_abort();
  static const int kSequencePrepareAbortFieldNumber = 4;
  const ::std::string& sequence_prepare_abort() const;
  void set_sequence_prepare_abort(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence_prepare_abort(::std::string&& value);
  #endif
  void set_sequence_prepare_abort(const char* value);
  void set_sequence_prepare_abort(const char* value, size_t size);
  ::std::string* mutable_sequence_prepare_abort();
  ::std::string* release_sequence_prepare_abort();
  void set_allocated_sequence_prepare_abort(::std::string* sequence_prepare_abort);

  // string sequence_on_success = 5;
  void clear_sequence_on_success();
  static const int kSequenceOnSuccessFieldNumber = 5;
  const ::std::string& sequence_on_success() const;
  void set_sequence_on_success(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence_on_success(::std::string&& value);
  #endif
  void set_sequence_on_success(const char* value);
  void set_sequence_on_success(const char* value, size_t size);
  ::std::string* mutable_sequence_on_success();
  ::std::string* release_sequence_on_success();
  void set_allocated_sequence_on_success(::std::string* sequence_on_success);

  // string sequence_on_failure = 6;
  void clear_sequence_on_failure();
  static const int kSequenceOnFailureFieldNumber = 6;
  const ::std::string& sequence_on_failure() const;
  void set_sequence_on_failure(const ::std::string& value);
  #if LANG_CXX11
  void set_sequence_on_failure(::std::string&& value);
  #endif
  void set_sequence_on_failure(const char* value);
  void set_sequence_on_failure(const char* value, size_t size);
  ::std::string* mutable_sequence_on_failure();
  ::std::string* release_sequence_on_failure();
  void set_allocated_sequence_on_failure(::std::string* sequence_on_failure);

  // .goldo.common.geometry.StaticPose start_pose = 1;
  bool has_start_pose() const;
  void clear_start_pose();
  static const int kStartPoseFieldNumber = 1;
  private:
  const ::goldo::common::geometry::StaticPose& _internal_start_pose() const;
  public:
  const ::goldo::common::geometry::StaticPose& start_pose() const;
  ::goldo::common::geometry::StaticPose* release_start_pose();
  ::goldo::common::geometry::StaticPose* mutable_start_pose();
  void set_allocated_start_pose(::goldo::common::geometry::StaticPose* start_pose);

  // int32 default_priority = 7;
  void clear_default_priority();
  static const int kDefaultPriorityFieldNumber = 7;
  ::google::protobuf::int32 default_priority() const;
  void set_default_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:goldo.strategy.ActionConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sequence_action_;
  ::google::protobuf::internal::ArenaStringPtr sequence_prepare_;
  ::google::protobuf::internal::ArenaStringPtr sequence_prepare_abort_;
  ::google::protobuf::internal::ArenaStringPtr sequence_on_success_;
  ::google::protobuf::internal::ArenaStringPtr sequence_on_failure_;
  ::goldo::common::geometry::StaticPose* start_pose_;
  ::google::protobuf::int32 default_priority_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fstrategy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StrategyConfig_ActionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<StrategyConfig_ActionsEntry_DoNotUse, 
    ::std::string, ::goldo::strategy::ActionConfig,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<StrategyConfig_ActionsEntry_DoNotUse, 
    ::std::string, ::goldo::strategy::ActionConfig,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  StrategyConfig_ActionsEntry_DoNotUse();
  StrategyConfig_ActionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const StrategyConfig_ActionsEntry_DoNotUse& other);
  static const StrategyConfig_ActionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StrategyConfig_ActionsEntry_DoNotUse*>(&_StrategyConfig_ActionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class StrategyConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.strategy.StrategyConfig) */ {
 public:
  StrategyConfig();
  virtual ~StrategyConfig();

  StrategyConfig(const StrategyConfig& from);

  inline StrategyConfig& operator=(const StrategyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StrategyConfig(StrategyConfig&& from) noexcept
    : StrategyConfig() {
    *this = ::std::move(from);
  }

  inline StrategyConfig& operator=(StrategyConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrategyConfig* internal_default_instance() {
    return reinterpret_cast<const StrategyConfig*>(
               &_StrategyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StrategyConfig* other);
  friend void swap(StrategyConfig& a, StrategyConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StrategyConfig* New() const final {
    return CreateMaybeMessage<StrategyConfig>(NULL);
  }

  StrategyConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StrategyConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StrategyConfig& from);
  void MergeFrom(const StrategyConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrategyConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .goldo.strategy.ActionConfig> actions = 1;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::goldo::strategy::ActionConfig >&
      actions() const;
  ::google::protobuf::Map< ::std::string, ::goldo::strategy::ActionConfig >*
      mutable_actions();

  // repeated .goldo.strategy.Area areas = 2;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 2;
  ::goldo::strategy::Area* mutable_areas(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::strategy::Area >*
      mutable_areas();
  const ::goldo::strategy::Area& areas(int index) const;
  ::goldo::strategy::Area* add_areas();
  const ::google::protobuf::RepeatedPtrField< ::goldo::strategy::Area >&
      areas() const;

  // @@protoc_insertion_point(class_scope:goldo.strategy.StrategyConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      StrategyConfig_ActionsEntry_DoNotUse,
      ::std::string, ::goldo::strategy::ActionConfig,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > actions_;
  ::google::protobuf::RepeatedPtrField< ::goldo::strategy::Area > areas_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fstrategy_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StrategyState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.strategy.StrategyState) */ {
 public:
  StrategyState();
  virtual ~StrategyState();

  StrategyState(const StrategyState& from);

  inline StrategyState& operator=(const StrategyState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StrategyState(StrategyState&& from) noexcept
    : StrategyState() {
    *this = ::std::move(from);
  }

  inline StrategyState& operator=(StrategyState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrategyState* internal_default_instance() {
    return reinterpret_cast<const StrategyState*>(
               &_StrategyState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(StrategyState* other);
  friend void swap(StrategyState& a, StrategyState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StrategyState* New() const final {
    return CreateMaybeMessage<StrategyState>(NULL);
  }

  StrategyState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StrategyState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StrategyState& from);
  void MergeFrom(const StrategyState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrategyState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:goldo.strategy.StrategyState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fstrategy_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Area

// string name = 1;
inline void Area::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Area::name() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.Area.name)
  return name_.GetNoArena();
}
inline void Area::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.Area.name)
}
#if LANG_CXX11
inline void Area::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.Area.name)
}
#endif
inline void Area::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.Area.name)
}
inline void Area::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.Area.name)
}
inline ::std::string* Area::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.Area.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Area::release_name() {
  // @@protoc_insertion_point(field_release:goldo.strategy.Area.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Area::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.Area.name)
}

// .goldo.common.geometry.Box box = 2;
inline bool Area::has_box() const {
  return geometry_case() == kBox;
}
inline void Area::set_has_box() {
  _oneof_case_[0] = kBox;
}
inline const ::goldo::common::geometry::Box& Area::_internal_box() const {
  return *geometry_.box_;
}
inline ::goldo::common::geometry::Box* Area::release_box() {
  // @@protoc_insertion_point(field_release:goldo.strategy.Area.box)
  if (has_box()) {
    clear_has_geometry();
      ::goldo::common::geometry::Box* temp = geometry_.box_;
    geometry_.box_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::goldo::common::geometry::Box& Area::box() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.Area.box)
  return has_box()
      ? *geometry_.box_
      : *reinterpret_cast< ::goldo::common::geometry::Box*>(&::goldo::common::geometry::_Box_default_instance_);
}
inline ::goldo::common::geometry::Box* Area::mutable_box() {
  if (!has_box()) {
    clear_geometry();
    set_has_box();
    geometry_.box_ = CreateMaybeMessage< ::goldo::common::geometry::Box >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:goldo.strategy.Area.box)
  return geometry_.box_;
}

// .goldo.common.geometry.Circle circle = 3;
inline bool Area::has_circle() const {
  return geometry_case() == kCircle;
}
inline void Area::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline const ::goldo::common::geometry::Circle& Area::_internal_circle() const {
  return *geometry_.circle_;
}
inline ::goldo::common::geometry::Circle* Area::release_circle() {
  // @@protoc_insertion_point(field_release:goldo.strategy.Area.circle)
  if (has_circle()) {
    clear_has_geometry();
      ::goldo::common::geometry::Circle* temp = geometry_.circle_;
    geometry_.circle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::goldo::common::geometry::Circle& Area::circle() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.Area.circle)
  return has_circle()
      ? *geometry_.circle_
      : *reinterpret_cast< ::goldo::common::geometry::Circle*>(&::goldo::common::geometry::_Circle_default_instance_);
}
inline ::goldo::common::geometry::Circle* Area::mutable_circle() {
  if (!has_circle()) {
    clear_geometry();
    set_has_circle();
    geometry_.circle_ = CreateMaybeMessage< ::goldo::common::geometry::Circle >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:goldo.strategy.Area.circle)
  return geometry_.circle_;
}

// .goldo.common.geometry.Polygon polygo = 4;
inline bool Area::has_polygo() const {
  return geometry_case() == kPolygo;
}
inline void Area::set_has_polygo() {
  _oneof_case_[0] = kPolygo;
}
inline const ::goldo::common::geometry::Polygon& Area::_internal_polygo() const {
  return *geometry_.polygo_;
}
inline ::goldo::common::geometry::Polygon* Area::release_polygo() {
  // @@protoc_insertion_point(field_release:goldo.strategy.Area.polygo)
  if (has_polygo()) {
    clear_has_geometry();
      ::goldo::common::geometry::Polygon* temp = geometry_.polygo_;
    geometry_.polygo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::goldo::common::geometry::Polygon& Area::polygo() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.Area.polygo)
  return has_polygo()
      ? *geometry_.polygo_
      : *reinterpret_cast< ::goldo::common::geometry::Polygon*>(&::goldo::common::geometry::_Polygon_default_instance_);
}
inline ::goldo::common::geometry::Polygon* Area::mutable_polygo() {
  if (!has_polygo()) {
    clear_geometry();
    set_has_polygo();
    geometry_.polygo_ = CreateMaybeMessage< ::goldo::common::geometry::Polygon >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:goldo.strategy.Area.polygo)
  return geometry_.polygo_;
}

inline bool Area::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void Area::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline Area::GeometryCase Area::geometry_case() const {
  return Area::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionConfig

// .goldo.common.geometry.StaticPose start_pose = 1;
inline bool ActionConfig::has_start_pose() const {
  return this != internal_default_instance() && start_pose_ != NULL;
}
inline const ::goldo::common::geometry::StaticPose& ActionConfig::_internal_start_pose() const {
  return *start_pose_;
}
inline const ::goldo::common::geometry::StaticPose& ActionConfig::start_pose() const {
  const ::goldo::common::geometry::StaticPose* p = start_pose_;
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.start_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::StaticPose*>(
      &::goldo::common::geometry::_StaticPose_default_instance_);
}
inline ::goldo::common::geometry::StaticPose* ActionConfig::release_start_pose() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.start_pose)
  
  ::goldo::common::geometry::StaticPose* temp = start_pose_;
  start_pose_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::StaticPose* ActionConfig::mutable_start_pose() {
  
  if (start_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::StaticPose>(GetArenaNoVirtual());
    start_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.start_pose)
  return start_pose_;
}
inline void ActionConfig::set_allocated_start_pose(::goldo::common::geometry::StaticPose* start_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_pose_);
  }
  if (start_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_pose, submessage_arena);
    }
    
  } else {
    
  }
  start_pose_ = start_pose;
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.start_pose)
}

// string sequence_action = 2;
inline void ActionConfig::clear_sequence_action() {
  sequence_action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionConfig::sequence_action() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.sequence_action)
  return sequence_action_.GetNoArena();
}
inline void ActionConfig::set_sequence_action(const ::std::string& value) {
  
  sequence_action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.sequence_action)
}
#if LANG_CXX11
inline void ActionConfig::set_sequence_action(::std::string&& value) {
  
  sequence_action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.ActionConfig.sequence_action)
}
#endif
inline void ActionConfig::set_sequence_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.ActionConfig.sequence_action)
}
inline void ActionConfig::set_sequence_action(const char* value, size_t size) {
  
  sequence_action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.ActionConfig.sequence_action)
}
inline ::std::string* ActionConfig::mutable_sequence_action() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.sequence_action)
  return sequence_action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionConfig::release_sequence_action() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.sequence_action)
  
  return sequence_action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionConfig::set_allocated_sequence_action(::std::string* sequence_action) {
  if (sequence_action != NULL) {
    
  } else {
    
  }
  sequence_action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence_action);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.sequence_action)
}

// string sequence_prepare = 3;
inline void ActionConfig::clear_sequence_prepare() {
  sequence_prepare_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionConfig::sequence_prepare() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.sequence_prepare)
  return sequence_prepare_.GetNoArena();
}
inline void ActionConfig::set_sequence_prepare(const ::std::string& value) {
  
  sequence_prepare_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.sequence_prepare)
}
#if LANG_CXX11
inline void ActionConfig::set_sequence_prepare(::std::string&& value) {
  
  sequence_prepare_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.ActionConfig.sequence_prepare)
}
#endif
inline void ActionConfig::set_sequence_prepare(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_prepare_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.ActionConfig.sequence_prepare)
}
inline void ActionConfig::set_sequence_prepare(const char* value, size_t size) {
  
  sequence_prepare_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.ActionConfig.sequence_prepare)
}
inline ::std::string* ActionConfig::mutable_sequence_prepare() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.sequence_prepare)
  return sequence_prepare_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionConfig::release_sequence_prepare() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.sequence_prepare)
  
  return sequence_prepare_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionConfig::set_allocated_sequence_prepare(::std::string* sequence_prepare) {
  if (sequence_prepare != NULL) {
    
  } else {
    
  }
  sequence_prepare_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence_prepare);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.sequence_prepare)
}

// string sequence_prepare_abort = 4;
inline void ActionConfig::clear_sequence_prepare_abort() {
  sequence_prepare_abort_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionConfig::sequence_prepare_abort() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.sequence_prepare_abort)
  return sequence_prepare_abort_.GetNoArena();
}
inline void ActionConfig::set_sequence_prepare_abort(const ::std::string& value) {
  
  sequence_prepare_abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.sequence_prepare_abort)
}
#if LANG_CXX11
inline void ActionConfig::set_sequence_prepare_abort(::std::string&& value) {
  
  sequence_prepare_abort_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.ActionConfig.sequence_prepare_abort)
}
#endif
inline void ActionConfig::set_sequence_prepare_abort(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_prepare_abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.ActionConfig.sequence_prepare_abort)
}
inline void ActionConfig::set_sequence_prepare_abort(const char* value, size_t size) {
  
  sequence_prepare_abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.ActionConfig.sequence_prepare_abort)
}
inline ::std::string* ActionConfig::mutable_sequence_prepare_abort() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.sequence_prepare_abort)
  return sequence_prepare_abort_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionConfig::release_sequence_prepare_abort() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.sequence_prepare_abort)
  
  return sequence_prepare_abort_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionConfig::set_allocated_sequence_prepare_abort(::std::string* sequence_prepare_abort) {
  if (sequence_prepare_abort != NULL) {
    
  } else {
    
  }
  sequence_prepare_abort_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence_prepare_abort);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.sequence_prepare_abort)
}

// string sequence_on_success = 5;
inline void ActionConfig::clear_sequence_on_success() {
  sequence_on_success_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionConfig::sequence_on_success() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.sequence_on_success)
  return sequence_on_success_.GetNoArena();
}
inline void ActionConfig::set_sequence_on_success(const ::std::string& value) {
  
  sequence_on_success_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.sequence_on_success)
}
#if LANG_CXX11
inline void ActionConfig::set_sequence_on_success(::std::string&& value) {
  
  sequence_on_success_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.ActionConfig.sequence_on_success)
}
#endif
inline void ActionConfig::set_sequence_on_success(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_on_success_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.ActionConfig.sequence_on_success)
}
inline void ActionConfig::set_sequence_on_success(const char* value, size_t size) {
  
  sequence_on_success_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.ActionConfig.sequence_on_success)
}
inline ::std::string* ActionConfig::mutable_sequence_on_success() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.sequence_on_success)
  return sequence_on_success_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionConfig::release_sequence_on_success() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.sequence_on_success)
  
  return sequence_on_success_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionConfig::set_allocated_sequence_on_success(::std::string* sequence_on_success) {
  if (sequence_on_success != NULL) {
    
  } else {
    
  }
  sequence_on_success_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence_on_success);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.sequence_on_success)
}

// string sequence_on_failure = 6;
inline void ActionConfig::clear_sequence_on_failure() {
  sequence_on_failure_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ActionConfig::sequence_on_failure() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.sequence_on_failure)
  return sequence_on_failure_.GetNoArena();
}
inline void ActionConfig::set_sequence_on_failure(const ::std::string& value) {
  
  sequence_on_failure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.sequence_on_failure)
}
#if LANG_CXX11
inline void ActionConfig::set_sequence_on_failure(::std::string&& value) {
  
  sequence_on_failure_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:goldo.strategy.ActionConfig.sequence_on_failure)
}
#endif
inline void ActionConfig::set_sequence_on_failure(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sequence_on_failure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:goldo.strategy.ActionConfig.sequence_on_failure)
}
inline void ActionConfig::set_sequence_on_failure(const char* value, size_t size) {
  
  sequence_on_failure_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:goldo.strategy.ActionConfig.sequence_on_failure)
}
inline ::std::string* ActionConfig::mutable_sequence_on_failure() {
  
  // @@protoc_insertion_point(field_mutable:goldo.strategy.ActionConfig.sequence_on_failure)
  return sequence_on_failure_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActionConfig::release_sequence_on_failure() {
  // @@protoc_insertion_point(field_release:goldo.strategy.ActionConfig.sequence_on_failure)
  
  return sequence_on_failure_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActionConfig::set_allocated_sequence_on_failure(::std::string* sequence_on_failure) {
  if (sequence_on_failure != NULL) {
    
  } else {
    
  }
  sequence_on_failure_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sequence_on_failure);
  // @@protoc_insertion_point(field_set_allocated:goldo.strategy.ActionConfig.sequence_on_failure)
}

// int32 default_priority = 7;
inline void ActionConfig::clear_default_priority() {
  default_priority_ = 0;
}
inline ::google::protobuf::int32 ActionConfig::default_priority() const {
  // @@protoc_insertion_point(field_get:goldo.strategy.ActionConfig.default_priority)
  return default_priority_;
}
inline void ActionConfig::set_default_priority(::google::protobuf::int32 value) {
  
  default_priority_ = value;
  // @@protoc_insertion_point(field_set:goldo.strategy.ActionConfig.default_priority)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StrategyConfig

// map<string, .goldo.strategy.ActionConfig> actions = 1;
inline int StrategyConfig::actions_size() const {
  return actions_.size();
}
inline void StrategyConfig::clear_actions() {
  actions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::goldo::strategy::ActionConfig >&
StrategyConfig::actions() const {
  // @@protoc_insertion_point(field_map:goldo.strategy.StrategyConfig.actions)
  return actions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::goldo::strategy::ActionConfig >*
StrategyConfig::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_map:goldo.strategy.StrategyConfig.actions)
  return actions_.MutableMap();
}

// repeated .goldo.strategy.Area areas = 2;
inline int StrategyConfig::areas_size() const {
  return areas_.size();
}
inline void StrategyConfig::clear_areas() {
  areas_.Clear();
}
inline ::goldo::strategy::Area* StrategyConfig::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.strategy.StrategyConfig.areas)
  return areas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::strategy::Area >*
StrategyConfig::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:goldo.strategy.StrategyConfig.areas)
  return &areas_;
}
inline const ::goldo::strategy::Area& StrategyConfig::areas(int index) const {
  // @@protoc_insertion_point(field_get:goldo.strategy.StrategyConfig.areas)
  return areas_.Get(index);
}
inline ::goldo::strategy::Area* StrategyConfig::add_areas() {
  // @@protoc_insertion_point(field_add:goldo.strategy.StrategyConfig.areas)
  return areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::strategy::Area >&
StrategyConfig::areas() const {
  // @@protoc_insertion_point(field_list:goldo.strategy.StrategyConfig.areas)
  return areas_;
}

// -------------------------------------------------------------------

// StrategyState

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace strategy
}  // namespace goldo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2fstrategy_2eproto
