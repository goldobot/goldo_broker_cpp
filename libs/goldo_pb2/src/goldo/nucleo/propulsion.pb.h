// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: goldo/nucleo/propulsion.proto

#ifndef PROTOBUF_INCLUDED_goldo_2fnucleo_2fpropulsion_2eproto
#define PROTOBUF_INCLUDED_goldo_2fnucleo_2fpropulsion_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "goldo/common/geometry.pb.h"
#include "goldo/pb2_options.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_goldo_2fnucleo_2fpropulsion_2eproto 

namespace protobuf_goldo_2fnucleo_2fpropulsion_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[28];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_goldo_2fnucleo_2fpropulsion_2eproto
namespace goldo {
namespace nucleo {
namespace propulsion {
class CmdEmpty;
class CmdEmptyDefaultTypeInternal;
extern CmdEmptyDefaultTypeInternal _CmdEmpty_default_instance_;
class CmdMeasureNormal;
class CmdMeasureNormalDefaultTypeInternal;
extern CmdMeasureNormalDefaultTypeInternal _CmdMeasureNormal_default_instance_;
class CmdSetAccelerationLimits;
class CmdSetAccelerationLimitsDefaultTypeInternal;
extern CmdSetAccelerationLimitsDefaultTypeInternal _CmdSetAccelerationLimits_default_instance_;
class CmdSetEnable;
class CmdSetEnableDefaultTypeInternal;
extern CmdSetEnableDefaultTypeInternal _CmdSetEnable_default_instance_;
class CmdSetEventSensorsMask;
class CmdSetEventSensorsMaskDefaultTypeInternal;
extern CmdSetEventSensorsMaskDefaultTypeInternal _CmdSetEventSensorsMask_default_instance_;
class CmdSetPose;
class CmdSetPoseDefaultTypeInternal;
extern CmdSetPoseDefaultTypeInternal _CmdSetPose_default_instance_;
class CmdSetTargetSpeed;
class CmdSetTargetSpeedDefaultTypeInternal;
extern CmdSetTargetSpeedDefaultTypeInternal _CmdSetTargetSpeed_default_instance_;
class CmdTransformPose;
class CmdTransformPoseDefaultTypeInternal;
extern CmdTransformPoseDefaultTypeInternal _CmdTransformPose_default_instance_;
class CommandStatus;
class CommandStatusDefaultTypeInternal;
extern CommandStatusDefaultTypeInternal _CommandStatus_default_instance_;
class ExecuteFaceDirection;
class ExecuteFaceDirectionDefaultTypeInternal;
extern ExecuteFaceDirectionDefaultTypeInternal _ExecuteFaceDirection_default_instance_;
class ExecuteMoveTo;
class ExecuteMoveToDefaultTypeInternal;
extern ExecuteMoveToDefaultTypeInternal _ExecuteMoveTo_default_instance_;
class ExecutePointTo;
class ExecutePointToDefaultTypeInternal;
extern ExecutePointToDefaultTypeInternal _ExecutePointTo_default_instance_;
class ExecuteReposition;
class ExecuteRepositionDefaultTypeInternal;
extern ExecuteRepositionDefaultTypeInternal _ExecuteReposition_default_instance_;
class ExecuteRotation;
class ExecuteRotationDefaultTypeInternal;
extern ExecuteRotationDefaultTypeInternal _ExecuteRotation_default_instance_;
class ExecuteTrajectory;
class ExecuteTrajectoryDefaultTypeInternal;
extern ExecuteTrajectoryDefaultTypeInternal _ExecuteTrajectory_default_instance_;
class ExecuteTranslation;
class ExecuteTranslationDefaultTypeInternal;
extern ExecuteTranslationDefaultTypeInternal _ExecuteTranslation_default_instance_;
class MotorsVelocitySetpoints;
class MotorsVelocitySetpointsDefaultTypeInternal;
extern MotorsVelocitySetpointsDefaultTypeInternal _MotorsVelocitySetpoints_default_instance_;
class OdometryConfig;
class OdometryConfigDefaultTypeInternal;
extern OdometryConfigDefaultTypeInternal _OdometryConfig_default_instance_;
class PIDConfig;
class PIDConfigDefaultTypeInternal;
extern PIDConfigDefaultTypeInternal _PIDConfig_default_instance_;
class PropulsionControllerConfig;
class PropulsionControllerConfigDefaultTypeInternal;
extern PropulsionControllerConfigDefaultTypeInternal _PropulsionControllerConfig_default_instance_;
class PropulsionEvent;
class PropulsionEventDefaultTypeInternal;
extern PropulsionEventDefaultTypeInternal _PropulsionEvent_default_instance_;
class PropulsionLowLevelControllerConfig;
class PropulsionLowLevelControllerConfigDefaultTypeInternal;
extern PropulsionLowLevelControllerConfigDefaultTypeInternal _PropulsionLowLevelControllerConfig_default_instance_;
class PropulsionLowLevelPIDConfig;
class PropulsionLowLevelPIDConfigDefaultTypeInternal;
extern PropulsionLowLevelPIDConfigDefaultTypeInternal _PropulsionLowLevelPIDConfig_default_instance_;
class PropulsionTaskConfig;
class PropulsionTaskConfigDefaultTypeInternal;
extern PropulsionTaskConfigDefaultTypeInternal _PropulsionTaskConfig_default_instance_;
class SetMotorsTorqueLimits;
class SetMotorsTorqueLimitsDefaultTypeInternal;
extern SetMotorsTorqueLimitsDefaultTypeInternal _SetMotorsTorqueLimits_default_instance_;
class StateChange;
class StateChangeDefaultTypeInternal;
extern StateChangeDefaultTypeInternal _StateChange_default_instance_;
class Telemetry;
class TelemetryDefaultTypeInternal;
extern TelemetryDefaultTypeInternal _Telemetry_default_instance_;
class TelemetryEx;
class TelemetryExDefaultTypeInternal;
extern TelemetryExDefaultTypeInternal _TelemetryEx_default_instance_;
}  // namespace propulsion
}  // namespace nucleo
}  // namespace goldo
namespace google {
namespace protobuf {
template<> ::goldo::nucleo::propulsion::CmdEmpty* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdEmpty>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdMeasureNormal* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdMeasureNormal>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdSetAccelerationLimits* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdSetAccelerationLimits>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdSetEnable* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdSetEnable>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdSetEventSensorsMask* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdSetEventSensorsMask>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdSetPose* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdSetPose>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdSetTargetSpeed* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdSetTargetSpeed>(Arena*);
template<> ::goldo::nucleo::propulsion::CmdTransformPose* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CmdTransformPose>(Arena*);
template<> ::goldo::nucleo::propulsion::CommandStatus* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::CommandStatus>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteFaceDirection* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteFaceDirection>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteMoveTo* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteMoveTo>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecutePointTo* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecutePointTo>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteReposition* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteReposition>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteRotation* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteRotation>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteTrajectory* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteTrajectory>(Arena*);
template<> ::goldo::nucleo::propulsion::ExecuteTranslation* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::ExecuteTranslation>(Arena*);
template<> ::goldo::nucleo::propulsion::MotorsVelocitySetpoints* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::MotorsVelocitySetpoints>(Arena*);
template<> ::goldo::nucleo::propulsion::OdometryConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::OdometryConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::PIDConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PIDConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::PropulsionControllerConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionControllerConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::PropulsionEvent* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionEvent>(Arena*);
template<> ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::PropulsionTaskConfig* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionTaskConfig>(Arena*);
template<> ::goldo::nucleo::propulsion::SetMotorsTorqueLimits* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::SetMotorsTorqueLimits>(Arena*);
template<> ::goldo::nucleo::propulsion::StateChange* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::StateChange>(Arena*);
template<> ::goldo::nucleo::propulsion::Telemetry* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::Telemetry>(Arena*);
template<> ::goldo::nucleo::propulsion::TelemetryEx* Arena::CreateMaybeMessage<::goldo::nucleo::propulsion::TelemetryEx>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace goldo {
namespace nucleo {
namespace propulsion {

enum PropulsionTaskConfig_MotorControllerType {
  PropulsionTaskConfig_MotorControllerType_None = 0,
  PropulsionTaskConfig_MotorControllerType_Pwm = 1,
  PropulsionTaskConfig_MotorControllerType_ODriveUART = 2,
  PropulsionTaskConfig_MotorControllerType_PropulsionTaskConfig_MotorControllerType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PropulsionTaskConfig_MotorControllerType_PropulsionTaskConfig_MotorControllerType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PropulsionTaskConfig_MotorControllerType_IsValid(int value);
const PropulsionTaskConfig_MotorControllerType PropulsionTaskConfig_MotorControllerType_MotorControllerType_MIN = PropulsionTaskConfig_MotorControllerType_None;
const PropulsionTaskConfig_MotorControllerType PropulsionTaskConfig_MotorControllerType_MotorControllerType_MAX = PropulsionTaskConfig_MotorControllerType_ODriveUART;
const int PropulsionTaskConfig_MotorControllerType_MotorControllerType_ARRAYSIZE = PropulsionTaskConfig_MotorControllerType_MotorControllerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PropulsionTaskConfig_MotorControllerType_descriptor();
inline const ::std::string& PropulsionTaskConfig_MotorControllerType_Name(PropulsionTaskConfig_MotorControllerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PropulsionTaskConfig_MotorControllerType_descriptor(), value);
}
inline bool PropulsionTaskConfig_MotorControllerType_Parse(
    const ::std::string& name, PropulsionTaskConfig_MotorControllerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropulsionTaskConfig_MotorControllerType>(
    PropulsionTaskConfig_MotorControllerType_descriptor(), name, value);
}
enum PropulsionControllerState {
  INACTIVE = 0,
  STOPPED = 1,
  FOLLOW_TRAJECTORY = 2,
  ROTATE = 3,
  REPOSITION = 4,
  MANUAL_CONTROL = 5,
  EMERGENCY_STOP = 6,
  ERROR = 7,
  PropulsionControllerState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PropulsionControllerState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PropulsionControllerState_IsValid(int value);
const PropulsionControllerState PropulsionControllerState_MIN = INACTIVE;
const PropulsionControllerState PropulsionControllerState_MAX = ERROR;
const int PropulsionControllerState_ARRAYSIZE = PropulsionControllerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* PropulsionControllerState_descriptor();
inline const ::std::string& PropulsionControllerState_Name(PropulsionControllerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    PropulsionControllerState_descriptor(), value);
}
inline bool PropulsionControllerState_Parse(
    const ::std::string& name, PropulsionControllerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropulsionControllerState>(
    PropulsionControllerState_descriptor(), name, value);
}
enum PropulsionControllerError {
  ERROR_NONE = 0,
  ERROR_EMERGENCY_STOP = 1,
  ERROR_ROBOT_BLOCKED = 2,
  ERROR_TRACKING_ERROR = 3,
  PropulsionControllerError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PropulsionControllerError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PropulsionControllerError_IsValid(int value);
const PropulsionControllerError PropulsionControllerError_MIN = ERROR_NONE;
const PropulsionControllerError PropulsionControllerError_MAX = ERROR_TRACKING_ERROR;
const int PropulsionControllerError_ARRAYSIZE = PropulsionControllerError_MAX + 1;

const ::google::protobuf::EnumDescriptor* PropulsionControllerError_descriptor();
inline const ::std::string& PropulsionControllerError_Name(PropulsionControllerError value) {
  return ::google::protobuf::internal::NameOfEnum(
    PropulsionControllerError_descriptor(), value);
}
inline bool PropulsionControllerError_Parse(
    const ::std::string& name, PropulsionControllerError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PropulsionControllerError>(
    PropulsionControllerError_descriptor(), name, value);
}
// ===================================================================

class StateChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.StateChange) */ {
 public:
  StateChange();
  virtual ~StateChange();

  StateChange(const StateChange& from);

  inline StateChange& operator=(const StateChange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StateChange(StateChange&& from) noexcept
    : StateChange() {
    *this = ::std::move(from);
  }

  inline StateChange& operator=(StateChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StateChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateChange* internal_default_instance() {
    return reinterpret_cast<const StateChange*>(
               &_StateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StateChange* other);
  friend void swap(StateChange& a, StateChange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StateChange* New() const final {
    return CreateMaybeMessage<StateChange>(NULL);
  }

  StateChange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StateChange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StateChange& from);
  void MergeFrom(const StateChange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // .goldo.nucleo.propulsion.PropulsionControllerState state = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::goldo::nucleo::propulsion::PropulsionControllerState state() const;
  void set_state(::goldo::nucleo::propulsion::PropulsionControllerState value);

  // .goldo.nucleo.propulsion.PropulsionControllerError error = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_error();
  static const int kErrorFieldNumber = 3;
  ::goldo::nucleo::propulsion::PropulsionControllerError error() const;
  void set_error(::goldo::nucleo::propulsion::PropulsionControllerError value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.StateChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timestamp_;
  int state_;
  int error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropulsionEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PropulsionEvent) */ {
 public:
  PropulsionEvent();
  virtual ~PropulsionEvent();

  PropulsionEvent(const PropulsionEvent& from);

  inline PropulsionEvent& operator=(const PropulsionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropulsionEvent(PropulsionEvent&& from) noexcept
    : PropulsionEvent() {
    *this = ::std::move(from);
  }

  inline PropulsionEvent& operator=(PropulsionEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropulsionEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropulsionEvent* internal_default_instance() {
    return reinterpret_cast<const PropulsionEvent*>(
               &_PropulsionEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PropulsionEvent* other);
  friend void swap(PropulsionEvent& a, PropulsionEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropulsionEvent* New() const final {
    return CreateMaybeMessage<PropulsionEvent>(NULL);
  }

  PropulsionEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropulsionEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropulsionEvent& from);
  void MergeFrom(const PropulsionEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropulsionEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Pose pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Pose& _internal_pose() const;
  public:
  const ::goldo::common::geometry::Pose& pose() const;
  ::goldo::common::geometry::Pose* release_pose();
  ::goldo::common::geometry::Pose* mutable_pose();
  void set_allocated_pose(::goldo::common::geometry::Pose* pose);

  // float parameter = 2;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  float parameter() const;
  void set_parameter(float value);

  // uint32 data1 = 3 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_data1();
  static const int kData1FieldNumber = 3;
  ::google::protobuf::uint32 data1() const;
  void set_data1(::google::protobuf::uint32 value);

  // uint32 data2 = 4 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_data2();
  static const int kData2FieldNumber = 4;
  ::google::protobuf::uint32 data2() const;
  void set_data2(::google::protobuf::uint32 value);

  // uint32 type = 5 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PropulsionEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Pose* pose_;
  float parameter_;
  ::google::protobuf::uint32 data1_;
  ::google::protobuf::uint32 data2_;
  ::google::protobuf::uint32 type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Telemetry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.Telemetry) */ {
 public:
  Telemetry();
  virtual ~Telemetry();

  Telemetry(const Telemetry& from);

  inline Telemetry& operator=(const Telemetry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Telemetry(Telemetry&& from) noexcept
    : Telemetry() {
    *this = ::std::move(from);
  }

  inline Telemetry& operator=(Telemetry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Telemetry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Telemetry* internal_default_instance() {
    return reinterpret_cast<const Telemetry*>(
               &_Telemetry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Telemetry* other);
  friend void swap(Telemetry& a, Telemetry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Telemetry* New() const final {
    return CreateMaybeMessage<Telemetry>(NULL);
  }

  Telemetry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Telemetry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Telemetry& from);
  void MergeFrom(const Telemetry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Telemetry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Pose pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Pose& _internal_pose() const;
  public:
  const ::goldo::common::geometry::Pose& pose() const;
  ::goldo::common::geometry::Pose* release_pose();
  ::goldo::common::geometry::Pose* mutable_pose();
  void set_allocated_pose(::goldo::common::geometry::Pose* pose);

  // uint32 left_encoder = 2;
  void clear_left_encoder();
  static const int kLeftEncoderFieldNumber = 2;
  ::google::protobuf::uint32 left_encoder() const;
  void set_left_encoder(::google::protobuf::uint32 value);

  // uint32 right_encoder = 3;
  void clear_right_encoder();
  static const int kRightEncoderFieldNumber = 3;
  ::google::protobuf::uint32 right_encoder() const;
  void set_right_encoder(::google::protobuf::uint32 value);

  // float left_pwm = 4;
  void clear_left_pwm();
  static const int kLeftPwmFieldNumber = 4;
  float left_pwm() const;
  void set_left_pwm(float value);

  // float right_pwm = 5;
  void clear_right_pwm();
  static const int kRightPwmFieldNumber = 5;
  float right_pwm() const;
  void set_right_pwm(float value);

  // .goldo.nucleo.propulsion.PropulsionControllerState state = 6;
  void clear_state();
  static const int kStateFieldNumber = 6;
  ::goldo::nucleo::propulsion::PropulsionControllerState state() const;
  void set_state(::goldo::nucleo::propulsion::PropulsionControllerState value);

  // uint32 error = 7;
  void clear_error();
  static const int kErrorFieldNumber = 7;
  ::google::protobuf::uint32 error() const;
  void set_error(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.Telemetry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Pose* pose_;
  ::google::protobuf::uint32 left_encoder_;
  ::google::protobuf::uint32 right_encoder_;
  float left_pwm_;
  float right_pwm_;
  int state_;
  ::google::protobuf::uint32 error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TelemetryEx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.TelemetryEx) */ {
 public:
  TelemetryEx();
  virtual ~TelemetryEx();

  TelemetryEx(const TelemetryEx& from);

  inline TelemetryEx& operator=(const TelemetryEx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TelemetryEx(TelemetryEx&& from) noexcept
    : TelemetryEx() {
    *this = ::std::move(from);
  }

  inline TelemetryEx& operator=(TelemetryEx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TelemetryEx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TelemetryEx* internal_default_instance() {
    return reinterpret_cast<const TelemetryEx*>(
               &_TelemetryEx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TelemetryEx* other);
  friend void swap(TelemetryEx& a, TelemetryEx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TelemetryEx* New() const final {
    return CreateMaybeMessage<TelemetryEx>(NULL);
  }

  TelemetryEx* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TelemetryEx>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TelemetryEx& from);
  void MergeFrom(const TelemetryEx& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryEx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Pose target_pose = 1;
  bool has_target_pose() const;
  void clear_target_pose();
  static const int kTargetPoseFieldNumber = 1;
  private:
  const ::goldo::common::geometry::Pose& _internal_target_pose() const;
  public:
  const ::goldo::common::geometry::Pose& target_pose() const;
  ::goldo::common::geometry::Pose* release_target_pose();
  ::goldo::common::geometry::Pose* mutable_target_pose();
  void set_allocated_target_pose(::goldo::common::geometry::Pose* target_pose);

  // .goldo.common.geometry.Point lookahead_position = 7;
  bool has_lookahead_position() const;
  void clear_lookahead_position();
  static const int kLookaheadPositionFieldNumber = 7;
  private:
  const ::goldo::common::geometry::Point& _internal_lookahead_position() const;
  public:
  const ::goldo::common::geometry::Point& lookahead_position() const;
  ::goldo::common::geometry::Point* release_lookahead_position();
  ::goldo::common::geometry::Point* mutable_lookahead_position();
  void set_allocated_lookahead_position(::goldo::common::geometry::Point* lookahead_position);

  // float error_longi = 2;
  void clear_error_longi();
  static const int kErrorLongiFieldNumber = 2;
  float error_longi() const;
  void set_error_longi(float value);

  // float error_lateral = 3;
  void clear_error_lateral();
  static const int kErrorLateralFieldNumber = 3;
  float error_lateral() const;
  void set_error_lateral(float value);

  // float error_yaw = 4;
  void clear_error_yaw();
  static const int kErrorYawFieldNumber = 4;
  float error_yaw() const;
  void set_error_yaw(float value);

  // float error_speed = 5;
  void clear_error_speed();
  static const int kErrorSpeedFieldNumber = 5;
  float error_speed() const;
  void set_error_speed(float value);

  // float error_yaw_rate = 6;
  void clear_error_yaw_rate();
  static const int kErrorYawRateFieldNumber = 6;
  float error_yaw_rate() const;
  void set_error_yaw_rate(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.TelemetryEx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Pose* target_pose_;
  ::goldo::common::geometry::Point* lookahead_position_;
  float error_longi_;
  float error_lateral_;
  float error_yaw_;
  float error_speed_;
  float error_yaw_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotorsVelocitySetpoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.MotorsVelocitySetpoints) */ {
 public:
  MotorsVelocitySetpoints();
  virtual ~MotorsVelocitySetpoints();

  MotorsVelocitySetpoints(const MotorsVelocitySetpoints& from);

  inline MotorsVelocitySetpoints& operator=(const MotorsVelocitySetpoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotorsVelocitySetpoints(MotorsVelocitySetpoints&& from) noexcept
    : MotorsVelocitySetpoints() {
    *this = ::std::move(from);
  }

  inline MotorsVelocitySetpoints& operator=(MotorsVelocitySetpoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorsVelocitySetpoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MotorsVelocitySetpoints* internal_default_instance() {
    return reinterpret_cast<const MotorsVelocitySetpoints*>(
               &_MotorsVelocitySetpoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MotorsVelocitySetpoints* other);
  friend void swap(MotorsVelocitySetpoints& a, MotorsVelocitySetpoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotorsVelocitySetpoints* New() const final {
    return CreateMaybeMessage<MotorsVelocitySetpoints>(NULL);
  }

  MotorsVelocitySetpoints* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MotorsVelocitySetpoints>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MotorsVelocitySetpoints& from);
  void MergeFrom(const MotorsVelocitySetpoints& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MotorsVelocitySetpoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float left_vel = 1;
  void clear_left_vel();
  static const int kLeftVelFieldNumber = 1;
  float left_vel() const;
  void set_left_vel(float value);

  // float right_vel = 2;
  void clear_right_vel();
  static const int kRightVelFieldNumber = 2;
  float right_vel() const;
  void set_right_vel(float value);

  // float left_current_feedforward = 3;
  void clear_left_current_feedforward();
  static const int kLeftCurrentFeedforwardFieldNumber = 3;
  float left_current_feedforward() const;
  void set_left_current_feedforward(float value);

  // float right_current_feedforward = 4;
  void clear_right_current_feedforward();
  static const int kRightCurrentFeedforwardFieldNumber = 4;
  float right_current_feedforward() const;
  void set_right_current_feedforward(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.MotorsVelocitySetpoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float left_vel_;
  float right_vel_;
  float left_current_feedforward_;
  float right_current_feedforward_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OdometryConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.OdometryConfig) */ {
 public:
  OdometryConfig();
  virtual ~OdometryConfig();

  OdometryConfig(const OdometryConfig& from);

  inline OdometryConfig& operator=(const OdometryConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OdometryConfig(OdometryConfig&& from) noexcept
    : OdometryConfig() {
    *this = ::std::move(from);
  }

  inline OdometryConfig& operator=(OdometryConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OdometryConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OdometryConfig* internal_default_instance() {
    return reinterpret_cast<const OdometryConfig*>(
               &_OdometryConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OdometryConfig* other);
  friend void swap(OdometryConfig& a, OdometryConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OdometryConfig* New() const final {
    return CreateMaybeMessage<OdometryConfig>(NULL);
  }

  OdometryConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OdometryConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OdometryConfig& from);
  void MergeFrom(const OdometryConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OdometryConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float dist_per_count_left = 1;
  void clear_dist_per_count_left();
  static const int kDistPerCountLeftFieldNumber = 1;
  float dist_per_count_left() const;
  void set_dist_per_count_left(float value);

  // float dist_per_count_right = 2;
  void clear_dist_per_count_right();
  static const int kDistPerCountRightFieldNumber = 2;
  float dist_per_count_right() const;
  void set_dist_per_count_right(float value);

  // float wheel_distance_left = 3;
  void clear_wheel_distance_left();
  static const int kWheelDistanceLeftFieldNumber = 3;
  float wheel_distance_left() const;
  void set_wheel_distance_left(float value);

  // float wheel_distance_right = 4;
  void clear_wheel_distance_right();
  static const int kWheelDistanceRightFieldNumber = 4;
  float wheel_distance_right() const;
  void set_wheel_distance_right(float value);

  // float speed_filter_frequency = 5;
  void clear_speed_filter_frequency();
  static const int kSpeedFilterFrequencyFieldNumber = 5;
  float speed_filter_frequency() const;
  void set_speed_filter_frequency(float value);

  // float accel_filter_frequency = 6;
  void clear_accel_filter_frequency();
  static const int kAccelFilterFrequencyFieldNumber = 6;
  float accel_filter_frequency() const;
  void set_accel_filter_frequency(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.OdometryConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float dist_per_count_left_;
  float dist_per_count_right_;
  float wheel_distance_left_;
  float wheel_distance_right_;
  float speed_filter_frequency_;
  float accel_filter_frequency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PIDConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PIDConfig) */ {
 public:
  PIDConfig();
  virtual ~PIDConfig();

  PIDConfig(const PIDConfig& from);

  inline PIDConfig& operator=(const PIDConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PIDConfig(PIDConfig&& from) noexcept
    : PIDConfig() {
    *this = ::std::move(from);
  }

  inline PIDConfig& operator=(PIDConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PIDConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PIDConfig* internal_default_instance() {
    return reinterpret_cast<const PIDConfig*>(
               &_PIDConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PIDConfig* other);
  friend void swap(PIDConfig& a, PIDConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PIDConfig* New() const final {
    return CreateMaybeMessage<PIDConfig>(NULL);
  }

  PIDConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PIDConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PIDConfig& from);
  void MergeFrom(const PIDConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PIDConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float kp = 1;
  void clear_kp();
  static const int kKpFieldNumber = 1;
  float kp() const;
  void set_kp(float value);

  // float ki = 2;
  void clear_ki();
  static const int kKiFieldNumber = 2;
  float ki() const;
  void set_ki(float value);

  // float kd = 3;
  void clear_kd();
  static const int kKdFieldNumber = 3;
  float kd() const;
  void set_kd(float value);

  // float lim_i = 4;
  void clear_lim_i();
  static const int kLimIFieldNumber = 4;
  float lim_i() const;
  void set_lim_i(float value);

  // float lim_d = 5;
  void clear_lim_d();
  static const int kLimDFieldNumber = 5;
  float lim_d() const;
  void set_lim_d(float value);

  // float d_filter_frequency = 6;
  void clear_d_filter_frequency();
  static const int kDFilterFrequencyFieldNumber = 6;
  float d_filter_frequency() const;
  void set_d_filter_frequency(float value);

  // float out_min = 7;
  void clear_out_min();
  static const int kOutMinFieldNumber = 7;
  float out_min() const;
  void set_out_min(float value);

  // float out_max = 8;
  void clear_out_max();
  static const int kOutMaxFieldNumber = 8;
  float out_max() const;
  void set_out_max(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PIDConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float kp_;
  float ki_;
  float kd_;
  float lim_i_;
  float lim_d_;
  float d_filter_frequency_;
  float out_min_;
  float out_max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropulsionLowLevelPIDConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig) */ {
 public:
  PropulsionLowLevelPIDConfig();
  virtual ~PropulsionLowLevelPIDConfig();

  PropulsionLowLevelPIDConfig(const PropulsionLowLevelPIDConfig& from);

  inline PropulsionLowLevelPIDConfig& operator=(const PropulsionLowLevelPIDConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropulsionLowLevelPIDConfig(PropulsionLowLevelPIDConfig&& from) noexcept
    : PropulsionLowLevelPIDConfig() {
    *this = ::std::move(from);
  }

  inline PropulsionLowLevelPIDConfig& operator=(PropulsionLowLevelPIDConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropulsionLowLevelPIDConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropulsionLowLevelPIDConfig* internal_default_instance() {
    return reinterpret_cast<const PropulsionLowLevelPIDConfig*>(
               &_PropulsionLowLevelPIDConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PropulsionLowLevelPIDConfig* other);
  friend void swap(PropulsionLowLevelPIDConfig& a, PropulsionLowLevelPIDConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropulsionLowLevelPIDConfig* New() const final {
    return CreateMaybeMessage<PropulsionLowLevelPIDConfig>(NULL);
  }

  PropulsionLowLevelPIDConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropulsionLowLevelPIDConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropulsionLowLevelPIDConfig& from);
  void MergeFrom(const PropulsionLowLevelPIDConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropulsionLowLevelPIDConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.nucleo.propulsion.PIDConfig speed = 1;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 1;
  private:
  const ::goldo::nucleo::propulsion::PIDConfig& _internal_speed() const;
  public:
  const ::goldo::nucleo::propulsion::PIDConfig& speed() const;
  ::goldo::nucleo::propulsion::PIDConfig* release_speed();
  ::goldo::nucleo::propulsion::PIDConfig* mutable_speed();
  void set_allocated_speed(::goldo::nucleo::propulsion::PIDConfig* speed);

  // .goldo.nucleo.propulsion.PIDConfig longi = 2;
  bool has_longi() const;
  void clear_longi();
  static const int kLongiFieldNumber = 2;
  private:
  const ::goldo::nucleo::propulsion::PIDConfig& _internal_longi() const;
  public:
  const ::goldo::nucleo::propulsion::PIDConfig& longi() const;
  ::goldo::nucleo::propulsion::PIDConfig* release_longi();
  ::goldo::nucleo::propulsion::PIDConfig* mutable_longi();
  void set_allocated_longi(::goldo::nucleo::propulsion::PIDConfig* longi);

  // .goldo.nucleo.propulsion.PIDConfig yaw_rate = 3;
  bool has_yaw_rate() const;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  private:
  const ::goldo::nucleo::propulsion::PIDConfig& _internal_yaw_rate() const;
  public:
  const ::goldo::nucleo::propulsion::PIDConfig& yaw_rate() const;
  ::goldo::nucleo::propulsion::PIDConfig* release_yaw_rate();
  ::goldo::nucleo::propulsion::PIDConfig* mutable_yaw_rate();
  void set_allocated_yaw_rate(::goldo::nucleo::propulsion::PIDConfig* yaw_rate);

  // .goldo.nucleo.propulsion.PIDConfig yaw = 4;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 4;
  private:
  const ::goldo::nucleo::propulsion::PIDConfig& _internal_yaw() const;
  public:
  const ::goldo::nucleo::propulsion::PIDConfig& yaw() const;
  ::goldo::nucleo::propulsion::PIDConfig* release_yaw();
  ::goldo::nucleo::propulsion::PIDConfig* mutable_yaw();
  void set_allocated_yaw(::goldo::nucleo::propulsion::PIDConfig* yaw);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::nucleo::propulsion::PIDConfig* speed_;
  ::goldo::nucleo::propulsion::PIDConfig* longi_;
  ::goldo::nucleo::propulsion::PIDConfig* yaw_rate_;
  ::goldo::nucleo::propulsion::PIDConfig* yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropulsionLowLevelControllerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig) */ {
 public:
  PropulsionLowLevelControllerConfig();
  virtual ~PropulsionLowLevelControllerConfig();

  PropulsionLowLevelControllerConfig(const PropulsionLowLevelControllerConfig& from);

  inline PropulsionLowLevelControllerConfig& operator=(const PropulsionLowLevelControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropulsionLowLevelControllerConfig(PropulsionLowLevelControllerConfig&& from) noexcept
    : PropulsionLowLevelControllerConfig() {
    *this = ::std::move(from);
  }

  inline PropulsionLowLevelControllerConfig& operator=(PropulsionLowLevelControllerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropulsionLowLevelControllerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropulsionLowLevelControllerConfig* internal_default_instance() {
    return reinterpret_cast<const PropulsionLowLevelControllerConfig*>(
               &_PropulsionLowLevelControllerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PropulsionLowLevelControllerConfig* other);
  friend void swap(PropulsionLowLevelControllerConfig& a, PropulsionLowLevelControllerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropulsionLowLevelControllerConfig* New() const final {
    return CreateMaybeMessage<PropulsionLowLevelControllerConfig>(NULL);
  }

  PropulsionLowLevelControllerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropulsionLowLevelControllerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropulsionLowLevelControllerConfig& from);
  void MergeFrom(const PropulsionLowLevelControllerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropulsionLowLevelControllerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float wheels_distance = 1;
  void clear_wheels_distance();
  static const int kWheelsDistanceFieldNumber = 1;
  float wheels_distance() const;
  void set_wheels_distance(float value);

  // float motors_speed_factor = 2;
  void clear_motors_speed_factor();
  static const int kMotorsSpeedFactorFieldNumber = 2;
  float motors_speed_factor() const;
  void set_motors_speed_factor(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float wheels_distance_;
  float motors_speed_factor_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropulsionControllerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PropulsionControllerConfig) */ {
 public:
  PropulsionControllerConfig();
  virtual ~PropulsionControllerConfig();

  PropulsionControllerConfig(const PropulsionControllerConfig& from);

  inline PropulsionControllerConfig& operator=(const PropulsionControllerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropulsionControllerConfig(PropulsionControllerConfig&& from) noexcept
    : PropulsionControllerConfig() {
    *this = ::std::move(from);
  }

  inline PropulsionControllerConfig& operator=(PropulsionControllerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropulsionControllerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropulsionControllerConfig* internal_default_instance() {
    return reinterpret_cast<const PropulsionControllerConfig*>(
               &_PropulsionControllerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(PropulsionControllerConfig* other);
  friend void swap(PropulsionControllerConfig& a, PropulsionControllerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropulsionControllerConfig* New() const final {
    return CreateMaybeMessage<PropulsionControllerConfig>(NULL);
  }

  PropulsionControllerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropulsionControllerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropulsionControllerConfig& from);
  void MergeFrom(const PropulsionControllerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropulsionControllerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig pid_configs = 2 [(.goldo.pb2_options.max_count) = 4, (.goldo.pb2_options.fixed_count) = true];
  int pid_configs_size() const;
  void clear_pid_configs();
  static const int kPidConfigsFieldNumber = 2;
  ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig* mutable_pid_configs(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig >*
      mutable_pid_configs();
  const ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig& pid_configs(int index) const;
  ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig* add_pid_configs();
  const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig >&
      pid_configs() const;

  // .goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig low_level_config = 1;
  bool has_low_level_config() const;
  void clear_low_level_config();
  static const int kLowLevelConfigFieldNumber = 1;
  private:
  const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig& _internal_low_level_config() const;
  public:
  const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig& low_level_config() const;
  ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* release_low_level_config();
  ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* mutable_low_level_config();
  void set_allocated_low_level_config(::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* low_level_config);

  // float lookahead_distance = 3;
  void clear_lookahead_distance();
  static const int kLookaheadDistanceFieldNumber = 3;
  float lookahead_distance() const;
  void set_lookahead_distance(float value);

  // float lookahead_time = 4;
  void clear_lookahead_time();
  static const int kLookaheadTimeFieldNumber = 4;
  float lookahead_time() const;
  void set_lookahead_time(float value);

  // float static_motor_speed_limit = 5;
  void clear_static_motor_speed_limit();
  static const int kStaticMotorSpeedLimitFieldNumber = 5;
  float static_motor_speed_limit() const;
  void set_static_motor_speed_limit(float value);

  // float cruise_motor_speed_limit = 6;
  void clear_cruise_motor_speed_limit();
  static const int kCruiseMotorSpeedLimitFieldNumber = 6;
  float cruise_motor_speed_limit() const;
  void set_cruise_motor_speed_limit(float value);

  // float reposition_motor_speed_limit = 7;
  void clear_reposition_motor_speed_limit();
  static const int kRepositionMotorSpeedLimitFieldNumber = 7;
  float reposition_motor_speed_limit() const;
  void set_reposition_motor_speed_limit(float value);

  // float static_torque_limit = 8;
  void clear_static_torque_limit();
  static const int kStaticTorqueLimitFieldNumber = 8;
  float static_torque_limit() const;
  void set_static_torque_limit(float value);

  // float cruise_torque_limit = 9;
  void clear_cruise_torque_limit();
  static const int kCruiseTorqueLimitFieldNumber = 9;
  float cruise_torque_limit() const;
  void set_cruise_torque_limit(float value);

  // float reposition_torque_limit = 10;
  void clear_reposition_torque_limit();
  static const int kRepositionTorqueLimitFieldNumber = 10;
  float reposition_torque_limit() const;
  void set_reposition_torque_limit(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PropulsionControllerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig > pid_configs_;
  ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* low_level_config_;
  float lookahead_distance_;
  float lookahead_time_;
  float static_motor_speed_limit_;
  float cruise_motor_speed_limit_;
  float reposition_motor_speed_limit_;
  float static_torque_limit_;
  float cruise_torque_limit_;
  float reposition_torque_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PropulsionTaskConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.PropulsionTaskConfig) */ {
 public:
  PropulsionTaskConfig();
  virtual ~PropulsionTaskConfig();

  PropulsionTaskConfig(const PropulsionTaskConfig& from);

  inline PropulsionTaskConfig& operator=(const PropulsionTaskConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PropulsionTaskConfig(PropulsionTaskConfig&& from) noexcept
    : PropulsionTaskConfig() {
    *this = ::std::move(from);
  }

  inline PropulsionTaskConfig& operator=(PropulsionTaskConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PropulsionTaskConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PropulsionTaskConfig* internal_default_instance() {
    return reinterpret_cast<const PropulsionTaskConfig*>(
               &_PropulsionTaskConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PropulsionTaskConfig* other);
  friend void swap(PropulsionTaskConfig& a, PropulsionTaskConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PropulsionTaskConfig* New() const final {
    return CreateMaybeMessage<PropulsionTaskConfig>(NULL);
  }

  PropulsionTaskConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PropulsionTaskConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PropulsionTaskConfig& from);
  void MergeFrom(const PropulsionTaskConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PropulsionTaskConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PropulsionTaskConfig_MotorControllerType MotorControllerType;
  static const MotorControllerType None =
    PropulsionTaskConfig_MotorControllerType_None;
  static const MotorControllerType Pwm =
    PropulsionTaskConfig_MotorControllerType_Pwm;
  static const MotorControllerType ODriveUART =
    PropulsionTaskConfig_MotorControllerType_ODriveUART;
  static inline bool MotorControllerType_IsValid(int value) {
    return PropulsionTaskConfig_MotorControllerType_IsValid(value);
  }
  static const MotorControllerType MotorControllerType_MIN =
    PropulsionTaskConfig_MotorControllerType_MotorControllerType_MIN;
  static const MotorControllerType MotorControllerType_MAX =
    PropulsionTaskConfig_MotorControllerType_MotorControllerType_MAX;
  static const int MotorControllerType_ARRAYSIZE =
    PropulsionTaskConfig_MotorControllerType_MotorControllerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MotorControllerType_descriptor() {
    return PropulsionTaskConfig_MotorControllerType_descriptor();
  }
  static inline const ::std::string& MotorControllerType_Name(MotorControllerType value) {
    return PropulsionTaskConfig_MotorControllerType_Name(value);
  }
  static inline bool MotorControllerType_Parse(const ::std::string& name,
      MotorControllerType* value) {
    return PropulsionTaskConfig_MotorControllerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .goldo.nucleo.propulsion.PropulsionTaskConfig.MotorControllerType motor_controller = 1 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_motor_controller();
  static const int kMotorControllerFieldNumber = 1;
  ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType motor_controller() const;
  void set_motor_controller(::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType value);

  // uint32 update_period_ms = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_update_period_ms();
  static const int kUpdatePeriodMsFieldNumber = 2;
  ::google::protobuf::uint32 update_period_ms() const;
  void set_update_period_ms(::google::protobuf::uint32 value);

  // uint32 telemetry_period_ms = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_telemetry_period_ms();
  static const int kTelemetryPeriodMsFieldNumber = 3;
  ::google::protobuf::uint32 telemetry_period_ms() const;
  void set_telemetry_period_ms(::google::protobuf::uint32 value);

  // uint32 telemetry_ex_period_ms = 4 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_telemetry_ex_period_ms();
  static const int kTelemetryExPeriodMsFieldNumber = 4;
  ::google::protobuf::uint32 telemetry_ex_period_ms() const;
  void set_telemetry_ex_period_ms(::google::protobuf::uint32 value);

  // uint32 pose_period_ms = 5 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_pose_period_ms();
  static const int kPosePeriodMsFieldNumber = 5;
  ::google::protobuf::uint32 pose_period_ms() const;
  void set_pose_period_ms(::google::protobuf::uint32 value);

  // uint32 odrive_telemetry_period_ms = 6 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_odrive_telemetry_period_ms();
  static const int kOdriveTelemetryPeriodMsFieldNumber = 6;
  ::google::protobuf::uint32 odrive_telemetry_period_ms() const;
  void set_odrive_telemetry_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.PropulsionTaskConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int motor_controller_;
  ::google::protobuf::uint32 update_period_ms_;
  ::google::protobuf::uint32 telemetry_period_ms_;
  ::google::protobuf::uint32 telemetry_ex_period_ms_;
  ::google::protobuf::uint32 pose_period_ms_;
  ::google::protobuf::uint32 odrive_telemetry_period_ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommandStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CommandStatus) */ {
 public:
  CommandStatus();
  virtual ~CommandStatus();

  CommandStatus(const CommandStatus& from);

  inline CommandStatus& operator=(const CommandStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommandStatus(CommandStatus&& from) noexcept
    : CommandStatus() {
    *this = ::std::move(from);
  }

  inline CommandStatus& operator=(CommandStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStatus* internal_default_instance() {
    return reinterpret_cast<const CommandStatus*>(
               &_CommandStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CommandStatus* other);
  friend void swap(CommandStatus& a, CommandStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommandStatus* New() const final {
    return CreateMaybeMessage<CommandStatus>(NULL);
  }

  CommandStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommandStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommandStatus& from);
  void MergeFrom(const CommandStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // uint32 sequence_number = 2 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::uint32 sequence_number() const;
  void set_sequence_number(::google::protobuf::uint32 value);

  // int32 status = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // int32 error = 4 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_error();
  static const int kErrorFieldNumber = 4;
  ::google::protobuf::int32 error() const;
  void set_error(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CommandStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 sequence_number_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetMotorsTorqueLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.SetMotorsTorqueLimits) */ {
 public:
  SetMotorsTorqueLimits();
  virtual ~SetMotorsTorqueLimits();

  SetMotorsTorqueLimits(const SetMotorsTorqueLimits& from);

  inline SetMotorsTorqueLimits& operator=(const SetMotorsTorqueLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetMotorsTorqueLimits(SetMotorsTorqueLimits&& from) noexcept
    : SetMotorsTorqueLimits() {
    *this = ::std::move(from);
  }

  inline SetMotorsTorqueLimits& operator=(SetMotorsTorqueLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetMotorsTorqueLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetMotorsTorqueLimits* internal_default_instance() {
    return reinterpret_cast<const SetMotorsTorqueLimits*>(
               &_SetMotorsTorqueLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(SetMotorsTorqueLimits* other);
  friend void swap(SetMotorsTorqueLimits& a, SetMotorsTorqueLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetMotorsTorqueLimits* New() const final {
    return CreateMaybeMessage<SetMotorsTorqueLimits>(NULL);
  }

  SetMotorsTorqueLimits* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetMotorsTorqueLimits>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetMotorsTorqueLimits& from);
  void MergeFrom(const SetMotorsTorqueLimits& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetMotorsTorqueLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float left = 2;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  float left() const;
  void set_left(float value);

  // float right = 3;
  void clear_right();
  static const int kRightFieldNumber = 3;
  float right() const;
  void set_right(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.SetMotorsTorqueLimits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float left_;
  float right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdEmpty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdEmpty) */ {
 public:
  CmdEmpty();
  virtual ~CmdEmpty();

  CmdEmpty(const CmdEmpty& from);

  inline CmdEmpty& operator=(const CmdEmpty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdEmpty(CmdEmpty&& from) noexcept
    : CmdEmpty() {
    *this = ::std::move(from);
  }

  inline CmdEmpty& operator=(CmdEmpty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdEmpty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdEmpty* internal_default_instance() {
    return reinterpret_cast<const CmdEmpty*>(
               &_CmdEmpty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CmdEmpty* other);
  friend void swap(CmdEmpty& a, CmdEmpty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdEmpty* New() const final {
    return CreateMaybeMessage<CmdEmpty>(NULL);
  }

  CmdEmpty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdEmpty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdEmpty& from);
  void MergeFrom(const CmdEmpty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdEmpty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdEmpty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdSetEnable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdSetEnable) */ {
 public:
  CmdSetEnable();
  virtual ~CmdSetEnable();

  CmdSetEnable(const CmdSetEnable& from);

  inline CmdSetEnable& operator=(const CmdSetEnable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdSetEnable(CmdSetEnable&& from) noexcept
    : CmdSetEnable() {
    *this = ::std::move(from);
  }

  inline CmdSetEnable& operator=(CmdSetEnable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdSetEnable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdSetEnable* internal_default_instance() {
    return reinterpret_cast<const CmdSetEnable*>(
               &_CmdSetEnable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CmdSetEnable* other);
  friend void swap(CmdSetEnable& a, CmdSetEnable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdSetEnable* New() const final {
    return CreateMaybeMessage<CmdSetEnable>(NULL);
  }

  CmdSetEnable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdSetEnable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdSetEnable& from);
  void MergeFrom(const CmdSetEnable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdSetEnable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // bool enable = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
  void clear_enable();
  static const int kEnableFieldNumber = 2;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdSetEnable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  bool enable_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdSetAccelerationLimits : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdSetAccelerationLimits) */ {
 public:
  CmdSetAccelerationLimits();
  virtual ~CmdSetAccelerationLimits();

  CmdSetAccelerationLimits(const CmdSetAccelerationLimits& from);

  inline CmdSetAccelerationLimits& operator=(const CmdSetAccelerationLimits& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdSetAccelerationLimits(CmdSetAccelerationLimits&& from) noexcept
    : CmdSetAccelerationLimits() {
    *this = ::std::move(from);
  }

  inline CmdSetAccelerationLimits& operator=(CmdSetAccelerationLimits&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdSetAccelerationLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdSetAccelerationLimits* internal_default_instance() {
    return reinterpret_cast<const CmdSetAccelerationLimits*>(
               &_CmdSetAccelerationLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CmdSetAccelerationLimits* other);
  friend void swap(CmdSetAccelerationLimits& a, CmdSetAccelerationLimits& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdSetAccelerationLimits* New() const final {
    return CreateMaybeMessage<CmdSetAccelerationLimits>(NULL);
  }

  CmdSetAccelerationLimits* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdSetAccelerationLimits>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdSetAccelerationLimits& from);
  void MergeFrom(const CmdSetAccelerationLimits& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdSetAccelerationLimits* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float accel = 2;
  void clear_accel();
  static const int kAccelFieldNumber = 2;
  float accel() const;
  void set_accel(float value);

  // float deccel = 3;
  void clear_deccel();
  static const int kDeccelFieldNumber = 3;
  float deccel() const;
  void set_deccel(float value);

  // float angular_accel = 4;
  void clear_angular_accel();
  static const int kAngularAccelFieldNumber = 4;
  float angular_accel() const;
  void set_angular_accel(float value);

  // float angular_deccel = 5;
  void clear_angular_deccel();
  static const int kAngularDeccelFieldNumber = 5;
  float angular_deccel() const;
  void set_angular_deccel(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdSetAccelerationLimits)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float accel_;
  float deccel_;
  float angular_accel_;
  float angular_deccel_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdSetPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdSetPose) */ {
 public:
  CmdSetPose();
  virtual ~CmdSetPose();

  CmdSetPose(const CmdSetPose& from);

  inline CmdSetPose& operator=(const CmdSetPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdSetPose(CmdSetPose&& from) noexcept
    : CmdSetPose() {
    *this = ::std::move(from);
  }

  inline CmdSetPose& operator=(CmdSetPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdSetPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdSetPose* internal_default_instance() {
    return reinterpret_cast<const CmdSetPose*>(
               &_CmdSetPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CmdSetPose* other);
  friend void swap(CmdSetPose& a, CmdSetPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdSetPose* New() const final {
    return CreateMaybeMessage<CmdSetPose>(NULL);
  }

  CmdSetPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdSetPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdSetPose& from);
  void MergeFrom(const CmdSetPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdSetPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Point& _internal_position() const;
  public:
  const ::goldo::common::geometry::Point& position() const;
  ::goldo::common::geometry::Point* release_position();
  ::goldo::common::geometry::Point* mutable_position();
  void set_allocated_position(::goldo::common::geometry::Point* position);

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float yaw = 3;
  void clear_yaw();
  static const int kYawFieldNumber = 3;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdSetPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* position_;
  ::google::protobuf::int32 sequence_number_;
  float yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdTransformPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdTransformPose) */ {
 public:
  CmdTransformPose();
  virtual ~CmdTransformPose();

  CmdTransformPose(const CmdTransformPose& from);

  inline CmdTransformPose& operator=(const CmdTransformPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdTransformPose(CmdTransformPose&& from) noexcept
    : CmdTransformPose() {
    *this = ::std::move(from);
  }

  inline CmdTransformPose& operator=(CmdTransformPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdTransformPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdTransformPose* internal_default_instance() {
    return reinterpret_cast<const CmdTransformPose*>(
               &_CmdTransformPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CmdTransformPose* other);
  friend void swap(CmdTransformPose& a, CmdTransformPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdTransformPose* New() const final {
    return CreateMaybeMessage<CmdTransformPose>(NULL);
  }

  CmdTransformPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdTransformPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdTransformPose& from);
  void MergeFrom(const CmdTransformPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdTransformPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point translation = 2;
  bool has_translation() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Point& _internal_translation() const;
  public:
  const ::goldo::common::geometry::Point& translation() const;
  ::goldo::common::geometry::Point* release_translation();
  ::goldo::common::geometry::Point* mutable_translation();
  void set_allocated_translation(::goldo::common::geometry::Point* translation);

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float rotation = 3;
  void clear_rotation();
  static const int kRotationFieldNumber = 3;
  float rotation() const;
  void set_rotation(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdTransformPose)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* translation_;
  ::google::protobuf::int32 sequence_number_;
  float rotation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdSetTargetSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdSetTargetSpeed) */ {
 public:
  CmdSetTargetSpeed();
  virtual ~CmdSetTargetSpeed();

  CmdSetTargetSpeed(const CmdSetTargetSpeed& from);

  inline CmdSetTargetSpeed& operator=(const CmdSetTargetSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdSetTargetSpeed(CmdSetTargetSpeed&& from) noexcept
    : CmdSetTargetSpeed() {
    *this = ::std::move(from);
  }

  inline CmdSetTargetSpeed& operator=(CmdSetTargetSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdSetTargetSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdSetTargetSpeed* internal_default_instance() {
    return reinterpret_cast<const CmdSetTargetSpeed*>(
               &_CmdSetTargetSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CmdSetTargetSpeed* other);
  friend void swap(CmdSetTargetSpeed& a, CmdSetTargetSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdSetTargetSpeed* New() const final {
    return CreateMaybeMessage<CmdSetTargetSpeed>(NULL);
  }

  CmdSetTargetSpeed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdSetTargetSpeed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdSetTargetSpeed& from);
  void MergeFrom(const CmdSetTargetSpeed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdSetTargetSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float target_speed = 3;
  void clear_target_speed();
  static const int kTargetSpeedFieldNumber = 3;
  float target_speed() const;
  void set_target_speed(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdSetTargetSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float target_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdMeasureNormal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdMeasureNormal) */ {
 public:
  CmdMeasureNormal();
  virtual ~CmdMeasureNormal();

  CmdMeasureNormal(const CmdMeasureNormal& from);

  inline CmdMeasureNormal& operator=(const CmdMeasureNormal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdMeasureNormal(CmdMeasureNormal&& from) noexcept
    : CmdMeasureNormal() {
    *this = ::std::move(from);
  }

  inline CmdMeasureNormal& operator=(CmdMeasureNormal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdMeasureNormal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdMeasureNormal* internal_default_instance() {
    return reinterpret_cast<const CmdMeasureNormal*>(
               &_CmdMeasureNormal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CmdMeasureNormal* other);
  friend void swap(CmdMeasureNormal& a, CmdMeasureNormal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdMeasureNormal* New() const final {
    return CreateMaybeMessage<CmdMeasureNormal>(NULL);
  }

  CmdMeasureNormal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdMeasureNormal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdMeasureNormal& from);
  void MergeFrom(const CmdMeasureNormal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdMeasureNormal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float angle = 2;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  float angle() const;
  void set_angle(float value);

  // float distance = 3;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdMeasureNormal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float angle_;
  float distance_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CmdSetEventSensorsMask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.CmdSetEventSensorsMask) */ {
 public:
  CmdSetEventSensorsMask();
  virtual ~CmdSetEventSensorsMask();

  CmdSetEventSensorsMask(const CmdSetEventSensorsMask& from);

  inline CmdSetEventSensorsMask& operator=(const CmdSetEventSensorsMask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CmdSetEventSensorsMask(CmdSetEventSensorsMask&& from) noexcept
    : CmdSetEventSensorsMask() {
    *this = ::std::move(from);
  }

  inline CmdSetEventSensorsMask& operator=(CmdSetEventSensorsMask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdSetEventSensorsMask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CmdSetEventSensorsMask* internal_default_instance() {
    return reinterpret_cast<const CmdSetEventSensorsMask*>(
               &_CmdSetEventSensorsMask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(CmdSetEventSensorsMask* other);
  friend void swap(CmdSetEventSensorsMask& a, CmdSetEventSensorsMask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CmdSetEventSensorsMask* New() const final {
    return CreateMaybeMessage<CmdSetEventSensorsMask>(NULL);
  }

  CmdSetEventSensorsMask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CmdSetEventSensorsMask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CmdSetEventSensorsMask& from);
  void MergeFrom(const CmdSetEventSensorsMask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CmdSetEventSensorsMask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // uint32 mask_rising = 2 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_mask_rising();
  static const int kMaskRisingFieldNumber = 2;
  ::google::protobuf::uint32 mask_rising() const;
  void set_mask_rising(::google::protobuf::uint32 value);

  // uint32 mask_falling = 3 [(.goldo.pb2_options.cpp_type) = UINT32];
  void clear_mask_falling();
  static const int kMaskFallingFieldNumber = 3;
  ::google::protobuf::uint32 mask_falling() const;
  void set_mask_falling(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.CmdSetEventSensorsMask)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  ::google::protobuf::uint32 mask_rising_;
  ::google::protobuf::uint32 mask_falling_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteTrajectory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteTrajectory) */ {
 public:
  ExecuteTrajectory();
  virtual ~ExecuteTrajectory();

  ExecuteTrajectory(const ExecuteTrajectory& from);

  inline ExecuteTrajectory& operator=(const ExecuteTrajectory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteTrajectory(ExecuteTrajectory&& from) noexcept
    : ExecuteTrajectory() {
    *this = ::std::move(from);
  }

  inline ExecuteTrajectory& operator=(ExecuteTrajectory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteTrajectory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteTrajectory* internal_default_instance() {
    return reinterpret_cast<const ExecuteTrajectory*>(
               &_ExecuteTrajectory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ExecuteTrajectory* other);
  friend void swap(ExecuteTrajectory& a, ExecuteTrajectory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteTrajectory* New() const final {
    return CreateMaybeMessage<ExecuteTrajectory>(NULL);
  }

  ExecuteTrajectory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteTrajectory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteTrajectory& from);
  void MergeFrom(const ExecuteTrajectory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteTrajectory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .goldo.common.geometry.Point points = 3;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  ::goldo::common::geometry::Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
      mutable_points();
  const ::goldo::common::geometry::Point& points(int index) const;
  ::goldo::common::geometry::Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
      points() const;

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float speed = 2;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  float speed() const;
  void set_speed(float value);

  // float reposition_distance = 4;
  void clear_reposition_distance();
  static const int kRepositionDistanceFieldNumber = 4;
  float reposition_distance() const;
  void set_reposition_distance(float value);

  // float reposition_speed = 5;
  void clear_reposition_speed();
  static const int kRepositionSpeedFieldNumber = 5;
  float reposition_speed() const;
  void set_reposition_speed(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteTrajectory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point > points_;
  ::google::protobuf::int32 sequence_number_;
  float speed_;
  float reposition_distance_;
  float reposition_speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteTranslation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteTranslation) */ {
 public:
  ExecuteTranslation();
  virtual ~ExecuteTranslation();

  ExecuteTranslation(const ExecuteTranslation& from);

  inline ExecuteTranslation& operator=(const ExecuteTranslation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteTranslation(ExecuteTranslation&& from) noexcept
    : ExecuteTranslation() {
    *this = ::std::move(from);
  }

  inline ExecuteTranslation& operator=(ExecuteTranslation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteTranslation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteTranslation* internal_default_instance() {
    return reinterpret_cast<const ExecuteTranslation*>(
               &_ExecuteTranslation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ExecuteTranslation* other);
  friend void swap(ExecuteTranslation& a, ExecuteTranslation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteTranslation* New() const final {
    return CreateMaybeMessage<ExecuteTranslation>(NULL);
  }

  ExecuteTranslation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteTranslation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteTranslation& from);
  void MergeFrom(const ExecuteTranslation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteTranslation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteTranslation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float distance_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteReposition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteReposition) */ {
 public:
  ExecuteReposition();
  virtual ~ExecuteReposition();

  ExecuteReposition(const ExecuteReposition& from);

  inline ExecuteReposition& operator=(const ExecuteReposition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteReposition(ExecuteReposition&& from) noexcept
    : ExecuteReposition() {
    *this = ::std::move(from);
  }

  inline ExecuteReposition& operator=(ExecuteReposition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteReposition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteReposition* internal_default_instance() {
    return reinterpret_cast<const ExecuteReposition*>(
               &_ExecuteReposition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ExecuteReposition* other);
  friend void swap(ExecuteReposition& a, ExecuteReposition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteReposition* New() const final {
    return CreateMaybeMessage<ExecuteReposition>(NULL);
  }

  ExecuteReposition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteReposition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteReposition& from);
  void MergeFrom(const ExecuteReposition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteReposition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float distance = 2;
  void clear_distance();
  static const int kDistanceFieldNumber = 2;
  float distance() const;
  void set_distance(float value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteReposition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float distance_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteRotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteRotation) */ {
 public:
  ExecuteRotation();
  virtual ~ExecuteRotation();

  ExecuteRotation(const ExecuteRotation& from);

  inline ExecuteRotation& operator=(const ExecuteRotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteRotation(ExecuteRotation&& from) noexcept
    : ExecuteRotation() {
    *this = ::std::move(from);
  }

  inline ExecuteRotation& operator=(ExecuteRotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteRotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteRotation* internal_default_instance() {
    return reinterpret_cast<const ExecuteRotation*>(
               &_ExecuteRotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ExecuteRotation* other);
  friend void swap(ExecuteRotation& a, ExecuteRotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteRotation* New() const final {
    return CreateMaybeMessage<ExecuteRotation>(NULL);
  }

  ExecuteRotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteRotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteRotation& from);
  void MergeFrom(const ExecuteRotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteRotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float angle = 2;
  void clear_angle();
  static const int kAngleFieldNumber = 2;
  float angle() const;
  void set_angle(float value);

  // float yaw_rate = 3;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteRotation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float angle_;
  float yaw_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteMoveTo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteMoveTo) */ {
 public:
  ExecuteMoveTo();
  virtual ~ExecuteMoveTo();

  ExecuteMoveTo(const ExecuteMoveTo& from);

  inline ExecuteMoveTo& operator=(const ExecuteMoveTo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteMoveTo(ExecuteMoveTo&& from) noexcept
    : ExecuteMoveTo() {
    *this = ::std::move(from);
  }

  inline ExecuteMoveTo& operator=(ExecuteMoveTo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteMoveTo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteMoveTo* internal_default_instance() {
    return reinterpret_cast<const ExecuteMoveTo*>(
               &_ExecuteMoveTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(ExecuteMoveTo* other);
  friend void swap(ExecuteMoveTo& a, ExecuteMoveTo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteMoveTo* New() const final {
    return CreateMaybeMessage<ExecuteMoveTo>(NULL);
  }

  ExecuteMoveTo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteMoveTo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteMoveTo& from);
  void MergeFrom(const ExecuteMoveTo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteMoveTo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point point = 2;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Point& _internal_point() const;
  public:
  const ::goldo::common::geometry::Point& point() const;
  ::goldo::common::geometry::Point* release_point();
  ::goldo::common::geometry::Point* mutable_point();
  void set_allocated_point(::goldo::common::geometry::Point* point);

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteMoveTo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* point_;
  ::google::protobuf::int32 sequence_number_;
  float speed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecutePointTo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecutePointTo) */ {
 public:
  ExecutePointTo();
  virtual ~ExecutePointTo();

  ExecutePointTo(const ExecutePointTo& from);

  inline ExecutePointTo& operator=(const ExecutePointTo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutePointTo(ExecutePointTo&& from) noexcept
    : ExecutePointTo() {
    *this = ::std::move(from);
  }

  inline ExecutePointTo& operator=(ExecutePointTo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutePointTo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutePointTo* internal_default_instance() {
    return reinterpret_cast<const ExecutePointTo*>(
               &_ExecutePointTo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ExecutePointTo* other);
  friend void swap(ExecutePointTo& a, ExecutePointTo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutePointTo* New() const final {
    return CreateMaybeMessage<ExecutePointTo>(NULL);
  }

  ExecutePointTo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecutePointTo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecutePointTo& from);
  void MergeFrom(const ExecutePointTo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutePointTo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .goldo.common.geometry.Point point = 2;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  private:
  const ::goldo::common::geometry::Point& _internal_point() const;
  public:
  const ::goldo::common::geometry::Point& point() const;
  ::goldo::common::geometry::Point* release_point();
  ::goldo::common::geometry::Point* mutable_point();
  void set_allocated_point(::goldo::common::geometry::Point* point);

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float yaw_rate = 3;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecutePointTo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::goldo::common::geometry::Point* point_;
  ::google::protobuf::int32 sequence_number_;
  float yaw_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecuteFaceDirection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:goldo.nucleo.propulsion.ExecuteFaceDirection) */ {
 public:
  ExecuteFaceDirection();
  virtual ~ExecuteFaceDirection();

  ExecuteFaceDirection(const ExecuteFaceDirection& from);

  inline ExecuteFaceDirection& operator=(const ExecuteFaceDirection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecuteFaceDirection(ExecuteFaceDirection&& from) noexcept
    : ExecuteFaceDirection() {
    *this = ::std::move(from);
  }

  inline ExecuteFaceDirection& operator=(ExecuteFaceDirection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteFaceDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecuteFaceDirection* internal_default_instance() {
    return reinterpret_cast<const ExecuteFaceDirection*>(
               &_ExecuteFaceDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ExecuteFaceDirection* other);
  friend void swap(ExecuteFaceDirection& a, ExecuteFaceDirection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecuteFaceDirection* New() const final {
    return CreateMaybeMessage<ExecuteFaceDirection>(NULL);
  }

  ExecuteFaceDirection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteFaceDirection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecuteFaceDirection& from);
  void MergeFrom(const ExecuteFaceDirection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteFaceDirection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 1;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // float yaw = 2;
  void clear_yaw();
  static const int kYawFieldNumber = 2;
  float yaw() const;
  void set_yaw(float value);

  // float yaw_rate = 3;
  void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  float yaw_rate() const;
  void set_yaw_rate(float value);

  // @@protoc_insertion_point(class_scope:goldo.nucleo.propulsion.ExecuteFaceDirection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 sequence_number_;
  float yaw_;
  float yaw_rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_goldo_2fnucleo_2fpropulsion_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StateChange

// uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void StateChange::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 StateChange::timestamp() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.StateChange.timestamp)
  return timestamp_;
}
inline void StateChange::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.StateChange.timestamp)
}

// .goldo.nucleo.propulsion.PropulsionControllerState state = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void StateChange::clear_state() {
  state_ = 0;
}
inline ::goldo::nucleo::propulsion::PropulsionControllerState StateChange::state() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.StateChange.state)
  return static_cast< ::goldo::nucleo::propulsion::PropulsionControllerState >(state_);
}
inline void StateChange::set_state(::goldo::nucleo::propulsion::PropulsionControllerState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.StateChange.state)
}

// .goldo.nucleo.propulsion.PropulsionControllerError error = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void StateChange::clear_error() {
  error_ = 0;
}
inline ::goldo::nucleo::propulsion::PropulsionControllerError StateChange::error() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.StateChange.error)
  return static_cast< ::goldo::nucleo::propulsion::PropulsionControllerError >(error_);
}
inline void StateChange::set_error(::goldo::nucleo::propulsion::PropulsionControllerError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.StateChange.error)
}

// -------------------------------------------------------------------

// PropulsionEvent

// .goldo.common.geometry.Pose pose = 1;
inline bool PropulsionEvent::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline const ::goldo::common::geometry::Pose& PropulsionEvent::_internal_pose() const {
  return *pose_;
}
inline const ::goldo::common::geometry::Pose& PropulsionEvent::pose() const {
  const ::goldo::common::geometry::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionEvent.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Pose*>(
      &::goldo::common::geometry::_Pose_default_instance_);
}
inline ::goldo::common::geometry::Pose* PropulsionEvent::release_pose() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionEvent.pose)
  
  ::goldo::common::geometry::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Pose* PropulsionEvent::mutable_pose() {
  
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionEvent.pose)
  return pose_;
}
inline void PropulsionEvent::set_allocated_pose(::goldo::common::geometry::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionEvent.pose)
}

// float parameter = 2;
inline void PropulsionEvent::clear_parameter() {
  parameter_ = 0;
}
inline float PropulsionEvent::parameter() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionEvent.parameter)
  return parameter_;
}
inline void PropulsionEvent::set_parameter(float value) {
  
  parameter_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionEvent.parameter)
}

// uint32 data1 = 3 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void PropulsionEvent::clear_data1() {
  data1_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionEvent::data1() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionEvent.data1)
  return data1_;
}
inline void PropulsionEvent::set_data1(::google::protobuf::uint32 value) {
  
  data1_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionEvent.data1)
}

// uint32 data2 = 4 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void PropulsionEvent::clear_data2() {
  data2_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionEvent::data2() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionEvent.data2)
  return data2_;
}
inline void PropulsionEvent::set_data2(::google::protobuf::uint32 value) {
  
  data2_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionEvent.data2)
}

// uint32 type = 5 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void PropulsionEvent::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionEvent::type() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionEvent.type)
  return type_;
}
inline void PropulsionEvent::set_type(::google::protobuf::uint32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionEvent.type)
}

// -------------------------------------------------------------------

// Telemetry

// .goldo.common.geometry.Pose pose = 1;
inline bool Telemetry::has_pose() const {
  return this != internal_default_instance() && pose_ != NULL;
}
inline const ::goldo::common::geometry::Pose& Telemetry::_internal_pose() const {
  return *pose_;
}
inline const ::goldo::common::geometry::Pose& Telemetry::pose() const {
  const ::goldo::common::geometry::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Pose*>(
      &::goldo::common::geometry::_Pose_default_instance_);
}
inline ::goldo::common::geometry::Pose* Telemetry::release_pose() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.Telemetry.pose)
  
  ::goldo::common::geometry::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Pose* Telemetry::mutable_pose() {
  
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.Telemetry.pose)
  return pose_;
}
inline void Telemetry::set_allocated_pose(::goldo::common::geometry::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pose_);
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.Telemetry.pose)
}

// uint32 left_encoder = 2;
inline void Telemetry::clear_left_encoder() {
  left_encoder_ = 0u;
}
inline ::google::protobuf::uint32 Telemetry::left_encoder() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.left_encoder)
  return left_encoder_;
}
inline void Telemetry::set_left_encoder(::google::protobuf::uint32 value) {
  
  left_encoder_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.left_encoder)
}

// uint32 right_encoder = 3;
inline void Telemetry::clear_right_encoder() {
  right_encoder_ = 0u;
}
inline ::google::protobuf::uint32 Telemetry::right_encoder() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.right_encoder)
  return right_encoder_;
}
inline void Telemetry::set_right_encoder(::google::protobuf::uint32 value) {
  
  right_encoder_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.right_encoder)
}

// float left_pwm = 4;
inline void Telemetry::clear_left_pwm() {
  left_pwm_ = 0;
}
inline float Telemetry::left_pwm() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.left_pwm)
  return left_pwm_;
}
inline void Telemetry::set_left_pwm(float value) {
  
  left_pwm_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.left_pwm)
}

// float right_pwm = 5;
inline void Telemetry::clear_right_pwm() {
  right_pwm_ = 0;
}
inline float Telemetry::right_pwm() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.right_pwm)
  return right_pwm_;
}
inline void Telemetry::set_right_pwm(float value) {
  
  right_pwm_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.right_pwm)
}

// .goldo.nucleo.propulsion.PropulsionControllerState state = 6;
inline void Telemetry::clear_state() {
  state_ = 0;
}
inline ::goldo::nucleo::propulsion::PropulsionControllerState Telemetry::state() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.state)
  return static_cast< ::goldo::nucleo::propulsion::PropulsionControllerState >(state_);
}
inline void Telemetry::set_state(::goldo::nucleo::propulsion::PropulsionControllerState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.state)
}

// uint32 error = 7;
inline void Telemetry::clear_error() {
  error_ = 0u;
}
inline ::google::protobuf::uint32 Telemetry::error() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.Telemetry.error)
  return error_;
}
inline void Telemetry::set_error(::google::protobuf::uint32 value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.Telemetry.error)
}

// -------------------------------------------------------------------

// TelemetryEx

// .goldo.common.geometry.Pose target_pose = 1;
inline bool TelemetryEx::has_target_pose() const {
  return this != internal_default_instance() && target_pose_ != NULL;
}
inline const ::goldo::common::geometry::Pose& TelemetryEx::_internal_target_pose() const {
  return *target_pose_;
}
inline const ::goldo::common::geometry::Pose& TelemetryEx::target_pose() const {
  const ::goldo::common::geometry::Pose* p = target_pose_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.target_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Pose*>(
      &::goldo::common::geometry::_Pose_default_instance_);
}
inline ::goldo::common::geometry::Pose* TelemetryEx::release_target_pose() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.TelemetryEx.target_pose)
  
  ::goldo::common::geometry::Pose* temp = target_pose_;
  target_pose_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Pose* TelemetryEx::mutable_target_pose() {
  
  if (target_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Pose>(GetArenaNoVirtual());
    target_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.TelemetryEx.target_pose)
  return target_pose_;
}
inline void TelemetryEx::set_allocated_target_pose(::goldo::common::geometry::Pose* target_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(target_pose_);
  }
  if (target_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      target_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, target_pose, submessage_arena);
    }
    
  } else {
    
  }
  target_pose_ = target_pose;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.TelemetryEx.target_pose)
}

// float error_longi = 2;
inline void TelemetryEx::clear_error_longi() {
  error_longi_ = 0;
}
inline float TelemetryEx::error_longi() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.error_longi)
  return error_longi_;
}
inline void TelemetryEx::set_error_longi(float value) {
  
  error_longi_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.TelemetryEx.error_longi)
}

// float error_lateral = 3;
inline void TelemetryEx::clear_error_lateral() {
  error_lateral_ = 0;
}
inline float TelemetryEx::error_lateral() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.error_lateral)
  return error_lateral_;
}
inline void TelemetryEx::set_error_lateral(float value) {
  
  error_lateral_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.TelemetryEx.error_lateral)
}

// float error_yaw = 4;
inline void TelemetryEx::clear_error_yaw() {
  error_yaw_ = 0;
}
inline float TelemetryEx::error_yaw() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.error_yaw)
  return error_yaw_;
}
inline void TelemetryEx::set_error_yaw(float value) {
  
  error_yaw_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.TelemetryEx.error_yaw)
}

// float error_speed = 5;
inline void TelemetryEx::clear_error_speed() {
  error_speed_ = 0;
}
inline float TelemetryEx::error_speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.error_speed)
  return error_speed_;
}
inline void TelemetryEx::set_error_speed(float value) {
  
  error_speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.TelemetryEx.error_speed)
}

// float error_yaw_rate = 6;
inline void TelemetryEx::clear_error_yaw_rate() {
  error_yaw_rate_ = 0;
}
inline float TelemetryEx::error_yaw_rate() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.error_yaw_rate)
  return error_yaw_rate_;
}
inline void TelemetryEx::set_error_yaw_rate(float value) {
  
  error_yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.TelemetryEx.error_yaw_rate)
}

// .goldo.common.geometry.Point lookahead_position = 7;
inline bool TelemetryEx::has_lookahead_position() const {
  return this != internal_default_instance() && lookahead_position_ != NULL;
}
inline const ::goldo::common::geometry::Point& TelemetryEx::_internal_lookahead_position() const {
  return *lookahead_position_;
}
inline const ::goldo::common::geometry::Point& TelemetryEx::lookahead_position() const {
  const ::goldo::common::geometry::Point* p = lookahead_position_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.TelemetryEx.lookahead_position)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* TelemetryEx::release_lookahead_position() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.TelemetryEx.lookahead_position)
  
  ::goldo::common::geometry::Point* temp = lookahead_position_;
  lookahead_position_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* TelemetryEx::mutable_lookahead_position() {
  
  if (lookahead_position_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    lookahead_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.TelemetryEx.lookahead_position)
  return lookahead_position_;
}
inline void TelemetryEx::set_allocated_lookahead_position(::goldo::common::geometry::Point* lookahead_position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lookahead_position_);
  }
  if (lookahead_position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lookahead_position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lookahead_position, submessage_arena);
    }
    
  } else {
    
  }
  lookahead_position_ = lookahead_position;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.TelemetryEx.lookahead_position)
}

// -------------------------------------------------------------------

// MotorsVelocitySetpoints

// float left_vel = 1;
inline void MotorsVelocitySetpoints::clear_left_vel() {
  left_vel_ = 0;
}
inline float MotorsVelocitySetpoints::left_vel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.MotorsVelocitySetpoints.left_vel)
  return left_vel_;
}
inline void MotorsVelocitySetpoints::set_left_vel(float value) {
  
  left_vel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.MotorsVelocitySetpoints.left_vel)
}

// float right_vel = 2;
inline void MotorsVelocitySetpoints::clear_right_vel() {
  right_vel_ = 0;
}
inline float MotorsVelocitySetpoints::right_vel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.MotorsVelocitySetpoints.right_vel)
  return right_vel_;
}
inline void MotorsVelocitySetpoints::set_right_vel(float value) {
  
  right_vel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.MotorsVelocitySetpoints.right_vel)
}

// float left_current_feedforward = 3;
inline void MotorsVelocitySetpoints::clear_left_current_feedforward() {
  left_current_feedforward_ = 0;
}
inline float MotorsVelocitySetpoints::left_current_feedforward() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.MotorsVelocitySetpoints.left_current_feedforward)
  return left_current_feedforward_;
}
inline void MotorsVelocitySetpoints::set_left_current_feedforward(float value) {
  
  left_current_feedforward_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.MotorsVelocitySetpoints.left_current_feedforward)
}

// float right_current_feedforward = 4;
inline void MotorsVelocitySetpoints::clear_right_current_feedforward() {
  right_current_feedforward_ = 0;
}
inline float MotorsVelocitySetpoints::right_current_feedforward() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.MotorsVelocitySetpoints.right_current_feedforward)
  return right_current_feedforward_;
}
inline void MotorsVelocitySetpoints::set_right_current_feedforward(float value) {
  
  right_current_feedforward_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.MotorsVelocitySetpoints.right_current_feedforward)
}

// -------------------------------------------------------------------

// OdometryConfig

// float dist_per_count_left = 1;
inline void OdometryConfig::clear_dist_per_count_left() {
  dist_per_count_left_ = 0;
}
inline float OdometryConfig::dist_per_count_left() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.dist_per_count_left)
  return dist_per_count_left_;
}
inline void OdometryConfig::set_dist_per_count_left(float value) {
  
  dist_per_count_left_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.dist_per_count_left)
}

// float dist_per_count_right = 2;
inline void OdometryConfig::clear_dist_per_count_right() {
  dist_per_count_right_ = 0;
}
inline float OdometryConfig::dist_per_count_right() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.dist_per_count_right)
  return dist_per_count_right_;
}
inline void OdometryConfig::set_dist_per_count_right(float value) {
  
  dist_per_count_right_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.dist_per_count_right)
}

// float wheel_distance_left = 3;
inline void OdometryConfig::clear_wheel_distance_left() {
  wheel_distance_left_ = 0;
}
inline float OdometryConfig::wheel_distance_left() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.wheel_distance_left)
  return wheel_distance_left_;
}
inline void OdometryConfig::set_wheel_distance_left(float value) {
  
  wheel_distance_left_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.wheel_distance_left)
}

// float wheel_distance_right = 4;
inline void OdometryConfig::clear_wheel_distance_right() {
  wheel_distance_right_ = 0;
}
inline float OdometryConfig::wheel_distance_right() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.wheel_distance_right)
  return wheel_distance_right_;
}
inline void OdometryConfig::set_wheel_distance_right(float value) {
  
  wheel_distance_right_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.wheel_distance_right)
}

// float speed_filter_frequency = 5;
inline void OdometryConfig::clear_speed_filter_frequency() {
  speed_filter_frequency_ = 0;
}
inline float OdometryConfig::speed_filter_frequency() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.speed_filter_frequency)
  return speed_filter_frequency_;
}
inline void OdometryConfig::set_speed_filter_frequency(float value) {
  
  speed_filter_frequency_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.speed_filter_frequency)
}

// float accel_filter_frequency = 6;
inline void OdometryConfig::clear_accel_filter_frequency() {
  accel_filter_frequency_ = 0;
}
inline float OdometryConfig::accel_filter_frequency() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.OdometryConfig.accel_filter_frequency)
  return accel_filter_frequency_;
}
inline void OdometryConfig::set_accel_filter_frequency(float value) {
  
  accel_filter_frequency_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.OdometryConfig.accel_filter_frequency)
}

// -------------------------------------------------------------------

// PIDConfig

// float kp = 1;
inline void PIDConfig::clear_kp() {
  kp_ = 0;
}
inline float PIDConfig::kp() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.kp)
  return kp_;
}
inline void PIDConfig::set_kp(float value) {
  
  kp_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.kp)
}

// float ki = 2;
inline void PIDConfig::clear_ki() {
  ki_ = 0;
}
inline float PIDConfig::ki() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.ki)
  return ki_;
}
inline void PIDConfig::set_ki(float value) {
  
  ki_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.ki)
}

// float kd = 3;
inline void PIDConfig::clear_kd() {
  kd_ = 0;
}
inline float PIDConfig::kd() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.kd)
  return kd_;
}
inline void PIDConfig::set_kd(float value) {
  
  kd_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.kd)
}

// float lim_i = 4;
inline void PIDConfig::clear_lim_i() {
  lim_i_ = 0;
}
inline float PIDConfig::lim_i() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.lim_i)
  return lim_i_;
}
inline void PIDConfig::set_lim_i(float value) {
  
  lim_i_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.lim_i)
}

// float lim_d = 5;
inline void PIDConfig::clear_lim_d() {
  lim_d_ = 0;
}
inline float PIDConfig::lim_d() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.lim_d)
  return lim_d_;
}
inline void PIDConfig::set_lim_d(float value) {
  
  lim_d_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.lim_d)
}

// float d_filter_frequency = 6;
inline void PIDConfig::clear_d_filter_frequency() {
  d_filter_frequency_ = 0;
}
inline float PIDConfig::d_filter_frequency() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.d_filter_frequency)
  return d_filter_frequency_;
}
inline void PIDConfig::set_d_filter_frequency(float value) {
  
  d_filter_frequency_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.d_filter_frequency)
}

// float out_min = 7;
inline void PIDConfig::clear_out_min() {
  out_min_ = 0;
}
inline float PIDConfig::out_min() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.out_min)
  return out_min_;
}
inline void PIDConfig::set_out_min(float value) {
  
  out_min_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.out_min)
}

// float out_max = 8;
inline void PIDConfig::clear_out_max() {
  out_max_ = 0;
}
inline float PIDConfig::out_max() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PIDConfig.out_max)
  return out_max_;
}
inline void PIDConfig::set_out_max(float value) {
  
  out_max_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PIDConfig.out_max)
}

// -------------------------------------------------------------------

// PropulsionLowLevelPIDConfig

// .goldo.nucleo.propulsion.PIDConfig speed = 1;
inline bool PropulsionLowLevelPIDConfig::has_speed() const {
  return this != internal_default_instance() && speed_ != NULL;
}
inline void PropulsionLowLevelPIDConfig::clear_speed() {
  if (GetArenaNoVirtual() == NULL && speed_ != NULL) {
    delete speed_;
  }
  speed_ = NULL;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::_internal_speed() const {
  return *speed_;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::speed() const {
  const ::goldo::nucleo::propulsion::PIDConfig* p = speed_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.speed)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PIDConfig*>(
      &::goldo::nucleo::propulsion::_PIDConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::release_speed() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.speed)
  
  ::goldo::nucleo::propulsion::PIDConfig* temp = speed_;
  speed_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::mutable_speed() {
  
  if (speed_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PIDConfig>(GetArenaNoVirtual());
    speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.speed)
  return speed_;
}
inline void PropulsionLowLevelPIDConfig::set_allocated_speed(::goldo::nucleo::propulsion::PIDConfig* speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete speed_;
  }
  if (speed) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    
  } else {
    
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.speed)
}

// .goldo.nucleo.propulsion.PIDConfig longi = 2;
inline bool PropulsionLowLevelPIDConfig::has_longi() const {
  return this != internal_default_instance() && longi_ != NULL;
}
inline void PropulsionLowLevelPIDConfig::clear_longi() {
  if (GetArenaNoVirtual() == NULL && longi_ != NULL) {
    delete longi_;
  }
  longi_ = NULL;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::_internal_longi() const {
  return *longi_;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::longi() const {
  const ::goldo::nucleo::propulsion::PIDConfig* p = longi_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.longi)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PIDConfig*>(
      &::goldo::nucleo::propulsion::_PIDConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::release_longi() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.longi)
  
  ::goldo::nucleo::propulsion::PIDConfig* temp = longi_;
  longi_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::mutable_longi() {
  
  if (longi_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PIDConfig>(GetArenaNoVirtual());
    longi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.longi)
  return longi_;
}
inline void PropulsionLowLevelPIDConfig::set_allocated_longi(::goldo::nucleo::propulsion::PIDConfig* longi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete longi_;
  }
  if (longi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      longi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longi, submessage_arena);
    }
    
  } else {
    
  }
  longi_ = longi;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.longi)
}

// .goldo.nucleo.propulsion.PIDConfig yaw_rate = 3;
inline bool PropulsionLowLevelPIDConfig::has_yaw_rate() const {
  return this != internal_default_instance() && yaw_rate_ != NULL;
}
inline void PropulsionLowLevelPIDConfig::clear_yaw_rate() {
  if (GetArenaNoVirtual() == NULL && yaw_rate_ != NULL) {
    delete yaw_rate_;
  }
  yaw_rate_ = NULL;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::_internal_yaw_rate() const {
  return *yaw_rate_;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::yaw_rate() const {
  const ::goldo::nucleo::propulsion::PIDConfig* p = yaw_rate_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw_rate)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PIDConfig*>(
      &::goldo::nucleo::propulsion::_PIDConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::release_yaw_rate() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw_rate)
  
  ::goldo::nucleo::propulsion::PIDConfig* temp = yaw_rate_;
  yaw_rate_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::mutable_yaw_rate() {
  
  if (yaw_rate_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PIDConfig>(GetArenaNoVirtual());
    yaw_rate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw_rate)
  return yaw_rate_;
}
inline void PropulsionLowLevelPIDConfig::set_allocated_yaw_rate(::goldo::nucleo::propulsion::PIDConfig* yaw_rate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yaw_rate_;
  }
  if (yaw_rate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yaw_rate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw_rate, submessage_arena);
    }
    
  } else {
    
  }
  yaw_rate_ = yaw_rate;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw_rate)
}

// .goldo.nucleo.propulsion.PIDConfig yaw = 4;
inline bool PropulsionLowLevelPIDConfig::has_yaw() const {
  return this != internal_default_instance() && yaw_ != NULL;
}
inline void PropulsionLowLevelPIDConfig::clear_yaw() {
  if (GetArenaNoVirtual() == NULL && yaw_ != NULL) {
    delete yaw_;
  }
  yaw_ = NULL;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::_internal_yaw() const {
  return *yaw_;
}
inline const ::goldo::nucleo::propulsion::PIDConfig& PropulsionLowLevelPIDConfig::yaw() const {
  const ::goldo::nucleo::propulsion::PIDConfig* p = yaw_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PIDConfig*>(
      &::goldo::nucleo::propulsion::_PIDConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::release_yaw() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw)
  
  ::goldo::nucleo::propulsion::PIDConfig* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PIDConfig* PropulsionLowLevelPIDConfig::mutable_yaw() {
  
  if (yaw_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PIDConfig>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw)
  return yaw_;
}
inline void PropulsionLowLevelPIDConfig::set_allocated_yaw(::goldo::nucleo::propulsion::PIDConfig* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete yaw_;
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig.yaw)
}

// -------------------------------------------------------------------

// PropulsionLowLevelControllerConfig

// float wheels_distance = 1;
inline void PropulsionLowLevelControllerConfig::clear_wheels_distance() {
  wheels_distance_ = 0;
}
inline float PropulsionLowLevelControllerConfig::wheels_distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig.wheels_distance)
  return wheels_distance_;
}
inline void PropulsionLowLevelControllerConfig::set_wheels_distance(float value) {
  
  wheels_distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig.wheels_distance)
}

// float motors_speed_factor = 2;
inline void PropulsionLowLevelControllerConfig::clear_motors_speed_factor() {
  motors_speed_factor_ = 0;
}
inline float PropulsionLowLevelControllerConfig::motors_speed_factor() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig.motors_speed_factor)
  return motors_speed_factor_;
}
inline void PropulsionLowLevelControllerConfig::set_motors_speed_factor(float value) {
  
  motors_speed_factor_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig.motors_speed_factor)
}

// -------------------------------------------------------------------

// PropulsionControllerConfig

// .goldo.nucleo.propulsion.PropulsionLowLevelControllerConfig low_level_config = 1;
inline bool PropulsionControllerConfig::has_low_level_config() const {
  return this != internal_default_instance() && low_level_config_ != NULL;
}
inline void PropulsionControllerConfig::clear_low_level_config() {
  if (GetArenaNoVirtual() == NULL && low_level_config_ != NULL) {
    delete low_level_config_;
  }
  low_level_config_ = NULL;
}
inline const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig& PropulsionControllerConfig::_internal_low_level_config() const {
  return *low_level_config_;
}
inline const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig& PropulsionControllerConfig::low_level_config() const {
  const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* p = low_level_config_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.low_level_config)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig*>(
      &::goldo::nucleo::propulsion::_PropulsionLowLevelControllerConfig_default_instance_);
}
inline ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* PropulsionControllerConfig::release_low_level_config() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.PropulsionControllerConfig.low_level_config)
  
  ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* temp = low_level_config_;
  low_level_config_ = NULL;
  return temp;
}
inline ::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* PropulsionControllerConfig::mutable_low_level_config() {
  
  if (low_level_config_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig>(GetArenaNoVirtual());
    low_level_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionControllerConfig.low_level_config)
  return low_level_config_;
}
inline void PropulsionControllerConfig::set_allocated_low_level_config(::goldo::nucleo::propulsion::PropulsionLowLevelControllerConfig* low_level_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete low_level_config_;
  }
  if (low_level_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      low_level_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, low_level_config, submessage_arena);
    }
    
  } else {
    
  }
  low_level_config_ = low_level_config;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.PropulsionControllerConfig.low_level_config)
}

// repeated .goldo.nucleo.propulsion.PropulsionLowLevelPIDConfig pid_configs = 2 [(.goldo.pb2_options.max_count) = 4, (.goldo.pb2_options.fixed_count) = true];
inline int PropulsionControllerConfig::pid_configs_size() const {
  return pid_configs_.size();
}
inline void PropulsionControllerConfig::clear_pid_configs() {
  pid_configs_.Clear();
}
inline ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig* PropulsionControllerConfig::mutable_pid_configs(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.PropulsionControllerConfig.pid_configs)
  return pid_configs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig >*
PropulsionControllerConfig::mutable_pid_configs() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.propulsion.PropulsionControllerConfig.pid_configs)
  return &pid_configs_;
}
inline const ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig& PropulsionControllerConfig::pid_configs(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.pid_configs)
  return pid_configs_.Get(index);
}
inline ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig* PropulsionControllerConfig::add_pid_configs() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.propulsion.PropulsionControllerConfig.pid_configs)
  return pid_configs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::nucleo::propulsion::PropulsionLowLevelPIDConfig >&
PropulsionControllerConfig::pid_configs() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.propulsion.PropulsionControllerConfig.pid_configs)
  return pid_configs_;
}

// float lookahead_distance = 3;
inline void PropulsionControllerConfig::clear_lookahead_distance() {
  lookahead_distance_ = 0;
}
inline float PropulsionControllerConfig::lookahead_distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.lookahead_distance)
  return lookahead_distance_;
}
inline void PropulsionControllerConfig::set_lookahead_distance(float value) {
  
  lookahead_distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.lookahead_distance)
}

// float lookahead_time = 4;
inline void PropulsionControllerConfig::clear_lookahead_time() {
  lookahead_time_ = 0;
}
inline float PropulsionControllerConfig::lookahead_time() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.lookahead_time)
  return lookahead_time_;
}
inline void PropulsionControllerConfig::set_lookahead_time(float value) {
  
  lookahead_time_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.lookahead_time)
}

// float static_motor_speed_limit = 5;
inline void PropulsionControllerConfig::clear_static_motor_speed_limit() {
  static_motor_speed_limit_ = 0;
}
inline float PropulsionControllerConfig::static_motor_speed_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.static_motor_speed_limit)
  return static_motor_speed_limit_;
}
inline void PropulsionControllerConfig::set_static_motor_speed_limit(float value) {
  
  static_motor_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.static_motor_speed_limit)
}

// float cruise_motor_speed_limit = 6;
inline void PropulsionControllerConfig::clear_cruise_motor_speed_limit() {
  cruise_motor_speed_limit_ = 0;
}
inline float PropulsionControllerConfig::cruise_motor_speed_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.cruise_motor_speed_limit)
  return cruise_motor_speed_limit_;
}
inline void PropulsionControllerConfig::set_cruise_motor_speed_limit(float value) {
  
  cruise_motor_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.cruise_motor_speed_limit)
}

// float reposition_motor_speed_limit = 7;
inline void PropulsionControllerConfig::clear_reposition_motor_speed_limit() {
  reposition_motor_speed_limit_ = 0;
}
inline float PropulsionControllerConfig::reposition_motor_speed_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.reposition_motor_speed_limit)
  return reposition_motor_speed_limit_;
}
inline void PropulsionControllerConfig::set_reposition_motor_speed_limit(float value) {
  
  reposition_motor_speed_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.reposition_motor_speed_limit)
}

// float static_torque_limit = 8;
inline void PropulsionControllerConfig::clear_static_torque_limit() {
  static_torque_limit_ = 0;
}
inline float PropulsionControllerConfig::static_torque_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.static_torque_limit)
  return static_torque_limit_;
}
inline void PropulsionControllerConfig::set_static_torque_limit(float value) {
  
  static_torque_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.static_torque_limit)
}

// float cruise_torque_limit = 9;
inline void PropulsionControllerConfig::clear_cruise_torque_limit() {
  cruise_torque_limit_ = 0;
}
inline float PropulsionControllerConfig::cruise_torque_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.cruise_torque_limit)
  return cruise_torque_limit_;
}
inline void PropulsionControllerConfig::set_cruise_torque_limit(float value) {
  
  cruise_torque_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.cruise_torque_limit)
}

// float reposition_torque_limit = 10;
inline void PropulsionControllerConfig::clear_reposition_torque_limit() {
  reposition_torque_limit_ = 0;
}
inline float PropulsionControllerConfig::reposition_torque_limit() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionControllerConfig.reposition_torque_limit)
  return reposition_torque_limit_;
}
inline void PropulsionControllerConfig::set_reposition_torque_limit(float value) {
  
  reposition_torque_limit_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionControllerConfig.reposition_torque_limit)
}

// -------------------------------------------------------------------

// PropulsionTaskConfig

// .goldo.nucleo.propulsion.PropulsionTaskConfig.MotorControllerType motor_controller = 1 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void PropulsionTaskConfig::clear_motor_controller() {
  motor_controller_ = 0;
}
inline ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType PropulsionTaskConfig::motor_controller() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.motor_controller)
  return static_cast< ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType >(motor_controller_);
}
inline void PropulsionTaskConfig::set_motor_controller(::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType value) {
  
  motor_controller_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.motor_controller)
}

// uint32 update_period_ms = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void PropulsionTaskConfig::clear_update_period_ms() {
  update_period_ms_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionTaskConfig::update_period_ms() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.update_period_ms)
  return update_period_ms_;
}
inline void PropulsionTaskConfig::set_update_period_ms(::google::protobuf::uint32 value) {
  
  update_period_ms_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.update_period_ms)
}

// uint32 telemetry_period_ms = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void PropulsionTaskConfig::clear_telemetry_period_ms() {
  telemetry_period_ms_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionTaskConfig::telemetry_period_ms() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.telemetry_period_ms)
  return telemetry_period_ms_;
}
inline void PropulsionTaskConfig::set_telemetry_period_ms(::google::protobuf::uint32 value) {
  
  telemetry_period_ms_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.telemetry_period_ms)
}

// uint32 telemetry_ex_period_ms = 4 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void PropulsionTaskConfig::clear_telemetry_ex_period_ms() {
  telemetry_ex_period_ms_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionTaskConfig::telemetry_ex_period_ms() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.telemetry_ex_period_ms)
  return telemetry_ex_period_ms_;
}
inline void PropulsionTaskConfig::set_telemetry_ex_period_ms(::google::protobuf::uint32 value) {
  
  telemetry_ex_period_ms_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.telemetry_ex_period_ms)
}

// uint32 pose_period_ms = 5 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void PropulsionTaskConfig::clear_pose_period_ms() {
  pose_period_ms_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionTaskConfig::pose_period_ms() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.pose_period_ms)
  return pose_period_ms_;
}
inline void PropulsionTaskConfig::set_pose_period_ms(::google::protobuf::uint32 value) {
  
  pose_period_ms_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.pose_period_ms)
}

// uint32 odrive_telemetry_period_ms = 6 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void PropulsionTaskConfig::clear_odrive_telemetry_period_ms() {
  odrive_telemetry_period_ms_ = 0u;
}
inline ::google::protobuf::uint32 PropulsionTaskConfig::odrive_telemetry_period_ms() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.PropulsionTaskConfig.odrive_telemetry_period_ms)
  return odrive_telemetry_period_ms_;
}
inline void PropulsionTaskConfig::set_odrive_telemetry_period_ms(::google::protobuf::uint32 value) {
  
  odrive_telemetry_period_ms_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.PropulsionTaskConfig.odrive_telemetry_period_ms)
}

// -------------------------------------------------------------------

// CommandStatus

// uint32 timestamp = 1 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void CommandStatus::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 CommandStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CommandStatus.timestamp)
  return timestamp_;
}
inline void CommandStatus::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CommandStatus.timestamp)
}

// uint32 sequence_number = 2 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CommandStatus::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::google::protobuf::uint32 CommandStatus::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CommandStatus.sequence_number)
  return sequence_number_;
}
inline void CommandStatus::set_sequence_number(::google::protobuf::uint32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CommandStatus.sequence_number)
}

// int32 status = 3 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void CommandStatus::clear_status() {
  status_ = 0;
}
inline ::google::protobuf::int32 CommandStatus::status() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CommandStatus.status)
  return status_;
}
inline void CommandStatus::set_status(::google::protobuf::int32 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CommandStatus.status)
}

// int32 error = 4 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void CommandStatus::clear_error() {
  error_ = 0;
}
inline ::google::protobuf::int32 CommandStatus::error() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CommandStatus.error)
  return error_;
}
inline void CommandStatus::set_error(::google::protobuf::int32 value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CommandStatus.error)
}

// -------------------------------------------------------------------

// SetMotorsTorqueLimits

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void SetMotorsTorqueLimits::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 SetMotorsTorqueLimits::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.SetMotorsTorqueLimits.sequence_number)
  return sequence_number_;
}
inline void SetMotorsTorqueLimits::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.SetMotorsTorqueLimits.sequence_number)
}

// float left = 2;
inline void SetMotorsTorqueLimits::clear_left() {
  left_ = 0;
}
inline float SetMotorsTorqueLimits::left() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.SetMotorsTorqueLimits.left)
  return left_;
}
inline void SetMotorsTorqueLimits::set_left(float value) {
  
  left_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.SetMotorsTorqueLimits.left)
}

// float right = 3;
inline void SetMotorsTorqueLimits::clear_right() {
  right_ = 0;
}
inline float SetMotorsTorqueLimits::right() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.SetMotorsTorqueLimits.right)
  return right_;
}
inline void SetMotorsTorqueLimits::set_right(float value) {
  
  right_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.SetMotorsTorqueLimits.right)
}

// -------------------------------------------------------------------

// CmdEmpty

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdEmpty::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdEmpty::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdEmpty.sequence_number)
  return sequence_number_;
}
inline void CmdEmpty::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdEmpty.sequence_number)
}

// -------------------------------------------------------------------

// CmdSetEnable

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdSetEnable::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdSetEnable::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetEnable.sequence_number)
  return sequence_number_;
}
inline void CmdSetEnable::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetEnable.sequence_number)
}

// bool enable = 2 [(.goldo.pb2_options.cpp_type) = UINT8];
inline void CmdSetEnable::clear_enable() {
  enable_ = false;
}
inline bool CmdSetEnable::enable() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetEnable.enable)
  return enable_;
}
inline void CmdSetEnable::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetEnable.enable)
}

// -------------------------------------------------------------------

// CmdSetAccelerationLimits

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdSetAccelerationLimits::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdSetAccelerationLimits::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetAccelerationLimits.sequence_number)
  return sequence_number_;
}
inline void CmdSetAccelerationLimits::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetAccelerationLimits.sequence_number)
}

// float accel = 2;
inline void CmdSetAccelerationLimits::clear_accel() {
  accel_ = 0;
}
inline float CmdSetAccelerationLimits::accel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetAccelerationLimits.accel)
  return accel_;
}
inline void CmdSetAccelerationLimits::set_accel(float value) {
  
  accel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetAccelerationLimits.accel)
}

// float deccel = 3;
inline void CmdSetAccelerationLimits::clear_deccel() {
  deccel_ = 0;
}
inline float CmdSetAccelerationLimits::deccel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetAccelerationLimits.deccel)
  return deccel_;
}
inline void CmdSetAccelerationLimits::set_deccel(float value) {
  
  deccel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetAccelerationLimits.deccel)
}

// float angular_accel = 4;
inline void CmdSetAccelerationLimits::clear_angular_accel() {
  angular_accel_ = 0;
}
inline float CmdSetAccelerationLimits::angular_accel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetAccelerationLimits.angular_accel)
  return angular_accel_;
}
inline void CmdSetAccelerationLimits::set_angular_accel(float value) {
  
  angular_accel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetAccelerationLimits.angular_accel)
}

// float angular_deccel = 5;
inline void CmdSetAccelerationLimits::clear_angular_deccel() {
  angular_deccel_ = 0;
}
inline float CmdSetAccelerationLimits::angular_deccel() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetAccelerationLimits.angular_deccel)
  return angular_deccel_;
}
inline void CmdSetAccelerationLimits::set_angular_deccel(float value) {
  
  angular_deccel_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetAccelerationLimits.angular_deccel)
}

// -------------------------------------------------------------------

// CmdSetPose

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdSetPose::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdSetPose::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetPose.sequence_number)
  return sequence_number_;
}
inline void CmdSetPose::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetPose.sequence_number)
}

// .goldo.common.geometry.Point position = 2;
inline bool CmdSetPose::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline const ::goldo::common::geometry::Point& CmdSetPose::_internal_position() const {
  return *position_;
}
inline const ::goldo::common::geometry::Point& CmdSetPose::position() const {
  const ::goldo::common::geometry::Point* p = position_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetPose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* CmdSetPose::release_position() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.CmdSetPose.position)
  
  ::goldo::common::geometry::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* CmdSetPose::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.CmdSetPose.position)
  return position_;
}
inline void CmdSetPose::set_allocated_position(::goldo::common::geometry::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_);
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.CmdSetPose.position)
}

// float yaw = 3;
inline void CmdSetPose::clear_yaw() {
  yaw_ = 0;
}
inline float CmdSetPose::yaw() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetPose.yaw)
  return yaw_;
}
inline void CmdSetPose::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetPose.yaw)
}

// -------------------------------------------------------------------

// CmdTransformPose

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdTransformPose::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdTransformPose::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdTransformPose.sequence_number)
  return sequence_number_;
}
inline void CmdTransformPose::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdTransformPose.sequence_number)
}

// .goldo.common.geometry.Point translation = 2;
inline bool CmdTransformPose::has_translation() const {
  return this != internal_default_instance() && translation_ != NULL;
}
inline const ::goldo::common::geometry::Point& CmdTransformPose::_internal_translation() const {
  return *translation_;
}
inline const ::goldo::common::geometry::Point& CmdTransformPose::translation() const {
  const ::goldo::common::geometry::Point* p = translation_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdTransformPose.translation)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* CmdTransformPose::release_translation() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.CmdTransformPose.translation)
  
  ::goldo::common::geometry::Point* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* CmdTransformPose::mutable_translation() {
  
  if (translation_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    translation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.CmdTransformPose.translation)
  return translation_;
}
inline void CmdTransformPose::set_allocated_translation(::goldo::common::geometry::Point* translation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(translation_);
  }
  if (translation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      translation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.CmdTransformPose.translation)
}

// float rotation = 3;
inline void CmdTransformPose::clear_rotation() {
  rotation_ = 0;
}
inline float CmdTransformPose::rotation() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdTransformPose.rotation)
  return rotation_;
}
inline void CmdTransformPose::set_rotation(float value) {
  
  rotation_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdTransformPose.rotation)
}

// -------------------------------------------------------------------

// CmdSetTargetSpeed

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdSetTargetSpeed::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdSetTargetSpeed::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetTargetSpeed.sequence_number)
  return sequence_number_;
}
inline void CmdSetTargetSpeed::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetTargetSpeed.sequence_number)
}

// float target_speed = 3;
inline void CmdSetTargetSpeed::clear_target_speed() {
  target_speed_ = 0;
}
inline float CmdSetTargetSpeed::target_speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetTargetSpeed.target_speed)
  return target_speed_;
}
inline void CmdSetTargetSpeed::set_target_speed(float value) {
  
  target_speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetTargetSpeed.target_speed)
}

// -------------------------------------------------------------------

// CmdMeasureNormal

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdMeasureNormal::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdMeasureNormal::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdMeasureNormal.sequence_number)
  return sequence_number_;
}
inline void CmdMeasureNormal::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdMeasureNormal.sequence_number)
}

// float angle = 2;
inline void CmdMeasureNormal::clear_angle() {
  angle_ = 0;
}
inline float CmdMeasureNormal::angle() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdMeasureNormal.angle)
  return angle_;
}
inline void CmdMeasureNormal::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdMeasureNormal.angle)
}

// float distance = 3;
inline void CmdMeasureNormal::clear_distance() {
  distance_ = 0;
}
inline float CmdMeasureNormal::distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdMeasureNormal.distance)
  return distance_;
}
inline void CmdMeasureNormal::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdMeasureNormal.distance)
}

// -------------------------------------------------------------------

// CmdSetEventSensorsMask

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void CmdSetEventSensorsMask::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 CmdSetEventSensorsMask::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetEventSensorsMask.sequence_number)
  return sequence_number_;
}
inline void CmdSetEventSensorsMask::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetEventSensorsMask.sequence_number)
}

// uint32 mask_rising = 2 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void CmdSetEventSensorsMask::clear_mask_rising() {
  mask_rising_ = 0u;
}
inline ::google::protobuf::uint32 CmdSetEventSensorsMask::mask_rising() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetEventSensorsMask.mask_rising)
  return mask_rising_;
}
inline void CmdSetEventSensorsMask::set_mask_rising(::google::protobuf::uint32 value) {
  
  mask_rising_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetEventSensorsMask.mask_rising)
}

// uint32 mask_falling = 3 [(.goldo.pb2_options.cpp_type) = UINT32];
inline void CmdSetEventSensorsMask::clear_mask_falling() {
  mask_falling_ = 0u;
}
inline ::google::protobuf::uint32 CmdSetEventSensorsMask::mask_falling() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.CmdSetEventSensorsMask.mask_falling)
  return mask_falling_;
}
inline void CmdSetEventSensorsMask::set_mask_falling(::google::protobuf::uint32 value) {
  
  mask_falling_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.CmdSetEventSensorsMask.mask_falling)
}

// -------------------------------------------------------------------

// ExecuteTrajectory

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteTrajectory::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteTrajectory::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTrajectory.sequence_number)
  return sequence_number_;
}
inline void ExecuteTrajectory::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTrajectory.sequence_number)
}

// float speed = 2;
inline void ExecuteTrajectory::clear_speed() {
  speed_ = 0;
}
inline float ExecuteTrajectory::speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTrajectory.speed)
  return speed_;
}
inline void ExecuteTrajectory::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTrajectory.speed)
}

// float reposition_distance = 4;
inline void ExecuteTrajectory::clear_reposition_distance() {
  reposition_distance_ = 0;
}
inline float ExecuteTrajectory::reposition_distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTrajectory.reposition_distance)
  return reposition_distance_;
}
inline void ExecuteTrajectory::set_reposition_distance(float value) {
  
  reposition_distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTrajectory.reposition_distance)
}

// float reposition_speed = 5;
inline void ExecuteTrajectory::clear_reposition_speed() {
  reposition_speed_ = 0;
}
inline float ExecuteTrajectory::reposition_speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTrajectory.reposition_speed)
  return reposition_speed_;
}
inline void ExecuteTrajectory::set_reposition_speed(float value) {
  
  reposition_speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTrajectory.reposition_speed)
}

// repeated .goldo.common.geometry.Point points = 3;
inline int ExecuteTrajectory::points_size() const {
  return points_.size();
}
inline ::goldo::common::geometry::Point* ExecuteTrajectory::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.ExecuteTrajectory.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >*
ExecuteTrajectory::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:goldo.nucleo.propulsion.ExecuteTrajectory.points)
  return &points_;
}
inline const ::goldo::common::geometry::Point& ExecuteTrajectory::points(int index) const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTrajectory.points)
  return points_.Get(index);
}
inline ::goldo::common::geometry::Point* ExecuteTrajectory::add_points() {
  // @@protoc_insertion_point(field_add:goldo.nucleo.propulsion.ExecuteTrajectory.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::goldo::common::geometry::Point >&
ExecuteTrajectory::points() const {
  // @@protoc_insertion_point(field_list:goldo.nucleo.propulsion.ExecuteTrajectory.points)
  return points_;
}

// -------------------------------------------------------------------

// ExecuteTranslation

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteTranslation::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteTranslation::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTranslation.sequence_number)
  return sequence_number_;
}
inline void ExecuteTranslation::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTranslation.sequence_number)
}

// float distance = 2;
inline void ExecuteTranslation::clear_distance() {
  distance_ = 0;
}
inline float ExecuteTranslation::distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTranslation.distance)
  return distance_;
}
inline void ExecuteTranslation::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTranslation.distance)
}

// float speed = 3;
inline void ExecuteTranslation::clear_speed() {
  speed_ = 0;
}
inline float ExecuteTranslation::speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteTranslation.speed)
  return speed_;
}
inline void ExecuteTranslation::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteTranslation.speed)
}

// -------------------------------------------------------------------

// ExecuteReposition

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteReposition::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteReposition::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteReposition.sequence_number)
  return sequence_number_;
}
inline void ExecuteReposition::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteReposition.sequence_number)
}

// float distance = 2;
inline void ExecuteReposition::clear_distance() {
  distance_ = 0;
}
inline float ExecuteReposition::distance() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteReposition.distance)
  return distance_;
}
inline void ExecuteReposition::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteReposition.distance)
}

// float speed = 3;
inline void ExecuteReposition::clear_speed() {
  speed_ = 0;
}
inline float ExecuteReposition::speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteReposition.speed)
  return speed_;
}
inline void ExecuteReposition::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteReposition.speed)
}

// -------------------------------------------------------------------

// ExecuteRotation

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteRotation::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteRotation::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteRotation.sequence_number)
  return sequence_number_;
}
inline void ExecuteRotation::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteRotation.sequence_number)
}

// float angle = 2;
inline void ExecuteRotation::clear_angle() {
  angle_ = 0;
}
inline float ExecuteRotation::angle() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteRotation.angle)
  return angle_;
}
inline void ExecuteRotation::set_angle(float value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteRotation.angle)
}

// float yaw_rate = 3;
inline void ExecuteRotation::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float ExecuteRotation::yaw_rate() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteRotation.yaw_rate)
  return yaw_rate_;
}
inline void ExecuteRotation::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteRotation.yaw_rate)
}

// -------------------------------------------------------------------

// ExecuteMoveTo

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteMoveTo::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteMoveTo::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteMoveTo.sequence_number)
  return sequence_number_;
}
inline void ExecuteMoveTo::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteMoveTo.sequence_number)
}

// .goldo.common.geometry.Point point = 2;
inline bool ExecuteMoveTo::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline const ::goldo::common::geometry::Point& ExecuteMoveTo::_internal_point() const {
  return *point_;
}
inline const ::goldo::common::geometry::Point& ExecuteMoveTo::point() const {
  const ::goldo::common::geometry::Point* p = point_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteMoveTo.point)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* ExecuteMoveTo::release_point() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.ExecuteMoveTo.point)
  
  ::goldo::common::geometry::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* ExecuteMoveTo::mutable_point() {
  
  if (point_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.ExecuteMoveTo.point)
  return point_;
}
inline void ExecuteMoveTo::set_allocated_point(::goldo::common::geometry::Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_);
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.ExecuteMoveTo.point)
}

// float speed = 3;
inline void ExecuteMoveTo::clear_speed() {
  speed_ = 0;
}
inline float ExecuteMoveTo::speed() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteMoveTo.speed)
  return speed_;
}
inline void ExecuteMoveTo::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteMoveTo.speed)
}

// -------------------------------------------------------------------

// ExecutePointTo

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecutePointTo::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecutePointTo::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecutePointTo.sequence_number)
  return sequence_number_;
}
inline void ExecutePointTo::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecutePointTo.sequence_number)
}

// .goldo.common.geometry.Point point = 2;
inline bool ExecutePointTo::has_point() const {
  return this != internal_default_instance() && point_ != NULL;
}
inline const ::goldo::common::geometry::Point& ExecutePointTo::_internal_point() const {
  return *point_;
}
inline const ::goldo::common::geometry::Point& ExecutePointTo::point() const {
  const ::goldo::common::geometry::Point* p = point_;
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecutePointTo.point)
  return p != NULL ? *p : *reinterpret_cast<const ::goldo::common::geometry::Point*>(
      &::goldo::common::geometry::_Point_default_instance_);
}
inline ::goldo::common::geometry::Point* ExecutePointTo::release_point() {
  // @@protoc_insertion_point(field_release:goldo.nucleo.propulsion.ExecutePointTo.point)
  
  ::goldo::common::geometry::Point* temp = point_;
  point_ = NULL;
  return temp;
}
inline ::goldo::common::geometry::Point* ExecutePointTo::mutable_point() {
  
  if (point_ == NULL) {
    auto* p = CreateMaybeMessage<::goldo::common::geometry::Point>(GetArenaNoVirtual());
    point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:goldo.nucleo.propulsion.ExecutePointTo.point)
  return point_;
}
inline void ExecutePointTo::set_allocated_point(::goldo::common::geometry::Point* point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(point_);
  }
  if (point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:goldo.nucleo.propulsion.ExecutePointTo.point)
}

// float yaw_rate = 3;
inline void ExecutePointTo::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float ExecutePointTo::yaw_rate() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecutePointTo.yaw_rate)
  return yaw_rate_;
}
inline void ExecutePointTo::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecutePointTo.yaw_rate)
}

// -------------------------------------------------------------------

// ExecuteFaceDirection

// int32 sequence_number = 1 [(.goldo.pb2_options.cpp_type) = UINT16];
inline void ExecuteFaceDirection::clear_sequence_number() {
  sequence_number_ = 0;
}
inline ::google::protobuf::int32 ExecuteFaceDirection::sequence_number() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteFaceDirection.sequence_number)
  return sequence_number_;
}
inline void ExecuteFaceDirection::set_sequence_number(::google::protobuf::int32 value) {
  
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteFaceDirection.sequence_number)
}

// float yaw = 2;
inline void ExecuteFaceDirection::clear_yaw() {
  yaw_ = 0;
}
inline float ExecuteFaceDirection::yaw() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteFaceDirection.yaw)
  return yaw_;
}
inline void ExecuteFaceDirection::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteFaceDirection.yaw)
}

// float yaw_rate = 3;
inline void ExecuteFaceDirection::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline float ExecuteFaceDirection::yaw_rate() const {
  // @@protoc_insertion_point(field_get:goldo.nucleo.propulsion.ExecuteFaceDirection.yaw_rate)
  return yaw_rate_;
}
inline void ExecuteFaceDirection::set_yaw_rate(float value) {
  
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:goldo.nucleo.propulsion.ExecuteFaceDirection.yaw_rate)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace propulsion
}  // namespace nucleo
}  // namespace goldo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType>() {
  return ::goldo::nucleo::propulsion::PropulsionTaskConfig_MotorControllerType_descriptor();
}
template <> struct is_proto_enum< ::goldo::nucleo::propulsion::PropulsionControllerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::nucleo::propulsion::PropulsionControllerState>() {
  return ::goldo::nucleo::propulsion::PropulsionControllerState_descriptor();
}
template <> struct is_proto_enum< ::goldo::nucleo::propulsion::PropulsionControllerError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::goldo::nucleo::propulsion::PropulsionControllerError>() {
  return ::goldo::nucleo::propulsion::PropulsionControllerError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_goldo_2fnucleo_2fpropulsion_2eproto
